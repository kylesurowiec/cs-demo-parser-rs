// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CEngineGotvSyncPacket {
    #[prost(uint64, optional, tag = "1")]
    pub match_id: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub instance_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub signupfragment: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub currentfragment: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "5")]
    pub tickrate: ::core::option::Option<f32>,
    #[prost(uint32, optional, tag = "6")]
    pub tick: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "8")]
    pub rtdelay: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "9")]
    pub rcvage: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "10")]
    pub keyframe_interval: ::core::option::Option<f32>,
    #[prost(uint32, optional, tag = "11")]
    pub cdndelay: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GameServerPing {
    #[prost(int32, optional, tag = "2")]
    pub ping: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub ip: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub instances: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataCenterPing {
    #[prost(fixed32, optional, tag = "1")]
    pub data_center_id: ::core::option::Option<u32>,
    #[prost(sint32, optional, tag = "2")]
    pub ping: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DetailedSearchStatistic {
    #[prost(uint32, optional, tag = "1")]
    pub game_type: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub search_time_avg: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub players_searching: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TournamentPlayer {
    #[prost(uint32, optional, tag = "1")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub player_nick: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub player_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "4")]
    pub player_dob: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "5")]
    pub player_flag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub player_location: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "7")]
    pub player_desc: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TournamentTeam {
    #[prost(int32, optional, tag = "1")]
    pub team_id: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub team_tag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub team_flag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub team_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "5")]
    pub players: ::prost::alloc::vec::Vec<TournamentPlayer>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TournamentEvent {
    #[prost(int32, optional, tag = "1")]
    pub event_id: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub event_tag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub event_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "4")]
    pub event_time_start: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub event_time_end: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "6")]
    pub event_public: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub event_stage_id: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "8")]
    pub event_stage_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "9")]
    pub active_section_id: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GlobalStatistics {
    #[prost(uint32, optional, tag = "1")]
    pub players_online: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub servers_online: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub players_searching: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub servers_available: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub ongoing_matches: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub search_time_avg: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "7")]
    pub search_statistics: ::prost::alloc::vec::Vec<DetailedSearchStatistic>,
    #[prost(string, optional, tag = "8")]
    pub main_post_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "9")]
    pub required_appid_version: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub pricesheet_version: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "11")]
    pub twitch_streams_version: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "12")]
    pub active_tournament_eventid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "13")]
    pub active_survey_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "14")]
    pub rtime32_cur: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "15")]
    pub rtime32_event_start: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationalStatisticDescription {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "2")]
    pub idkey: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationalStatisticElement {
    #[prost(uint32, optional, tag = "1")]
    pub idkey: ::core::option::Option<u32>,
    #[prost(int32, repeated, packed = "false", tag = "2")]
    pub values: ::prost::alloc::vec::Vec<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationalStatisticsPacket {
    #[prost(int32, optional, tag = "1")]
    pub packetid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub mstimestamp: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "3")]
    pub values: ::prost::alloc::vec::Vec<OperationalStatisticElement>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerRankingInfo {
    #[prost(uint32, optional, tag = "1")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub rank_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub wins: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "4")]
    pub rank_change: ::core::option::Option<f32>,
    #[prost(uint32, optional, tag = "6")]
    pub rank_type_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub tv_control: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerCommendationInfo {
    #[prost(uint32, optional, tag = "1")]
    pub cmd_friendly: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub cmd_teaching: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub cmd_leader: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerMedalsInfo {
    #[prost(uint32, repeated, packed = "false", tag = "7")]
    pub display_items_defidx: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub featured_display_item_defidx: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountActivity {
    #[prost(uint32, optional, tag = "1")]
    pub activity: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub mode: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub map: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "4")]
    pub matchid: ::core::option::Option<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TournamentMatchSetup {
    #[prost(int32, optional, tag = "1")]
    pub event_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub team_id_ct: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub team_id_t: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub event_stage_id: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerHltvInfo {
    #[prost(uint32, optional, tag = "1")]
    pub tv_udp_port: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "2")]
    pub tv_watch_key: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub tv_slots: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub tv_clients: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub tv_proxies: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub tv_time: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub game_type: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "9")]
    pub game_mapgroup: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "10")]
    pub game_map: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "11")]
    pub tv_master_steamid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "12")]
    pub tv_local_slots: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "13")]
    pub tv_local_clients: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "14")]
    pub tv_local_proxies: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "15")]
    pub tv_relay_slots: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "16")]
    pub tv_relay_clients: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "17")]
    pub tv_relay_proxies: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "18")]
    pub tv_relay_address: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "19")]
    pub tv_relay_port: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "20")]
    pub tv_relay_steamid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "21")]
    pub flags: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IpAddressMask {
    #[prost(uint32, optional, tag = "1")]
    pub a: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub b: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub c: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub d: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub bits: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub token: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgCsgoSteamUserStatChange {
    #[prost(int32, optional, tag = "1")]
    pub ecsgosteamuserstat: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub delta: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub absolute: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct XpProgressData {
    #[prost(uint32, optional, tag = "1")]
    pub xp_points: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub xp_category: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MatchEndItemUpdates {
    #[prost(uint64, optional, tag = "1")]
    pub item_id: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub item_attr_defidx: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub item_attr_delta_value: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScoreLeaderboardData {
    #[prost(uint64, optional, tag = "1")]
    pub quest_id: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub score: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "3")]
    pub accountentries: ::prost::alloc::vec::Vec<score_leaderboard_data::AccountEntries>,
    #[prost(message, repeated, tag = "5")]
    pub matchentries: ::prost::alloc::vec::Vec<score_leaderboard_data::Entry>,
}
/// Nested message and enum types in `ScoreLeaderboardData`.
pub mod score_leaderboard_data {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Entry {
        #[prost(uint32, optional, tag = "1")]
        pub tag: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub val: ::core::option::Option<u32>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AccountEntries {
        #[prost(uint32, optional, tag = "1")]
        pub accountid: ::core::option::Option<u32>,
        #[prost(message, repeated, tag = "2")]
        pub entries: ::prost::alloc::vec::Vec<Entry>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerQuestData {
    #[prost(uint32, optional, tag = "1")]
    pub quester_account_id: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "2")]
    pub quest_item_data: ::prost::alloc::vec::Vec<player_quest_data::QuestItemData>,
    #[prost(message, repeated, tag = "3")]
    pub xp_progress_data: ::prost::alloc::vec::Vec<XpProgressData>,
    #[prost(uint32, optional, tag = "4")]
    pub time_played: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub mm_game_mode: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "6")]
    pub item_updates: ::prost::alloc::vec::Vec<MatchEndItemUpdates>,
    #[prost(bool, optional, tag = "7")]
    pub operation_points_eligible: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "8")]
    pub userstatchanges: ::prost::alloc::vec::Vec<CMsgCsgoSteamUserStatChange>,
}
/// Nested message and enum types in `PlayerQuestData`.
pub mod player_quest_data {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct QuestItemData {
        #[prost(uint64, optional, tag = "1")]
        pub quest_id: ::core::option::Option<u64>,
        #[prost(int32, optional, tag = "2")]
        pub quest_normal_points_earned: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "3")]
        pub quest_bonus_points_earned: ::core::option::Option<i32>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeepPlayerStatsEntry {
    #[prost(uint32, optional, tag = "1")]
    pub accountid: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "2")]
    pub match_id: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub mm_game_mode: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub mapid: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "5")]
    pub b_starting_ct: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "6")]
    pub match_outcome: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub rounds_won: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub rounds_lost: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub stat_score: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "12")]
    pub stat_deaths: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "13")]
    pub stat_mvps: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "14")]
    pub enemy_kills: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "15")]
    pub enemy_headshots: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "16")]
    pub enemy_2ks: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "17")]
    pub enemy_3ks: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "18")]
    pub enemy_4ks: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "19")]
    pub total_damage: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "23")]
    pub engagements_entry_count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "24")]
    pub engagements_entry_wins: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "25")]
    pub engagements_1v1_count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "26")]
    pub engagements_1v1_wins: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "27")]
    pub engagements_1v2_count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "28")]
    pub engagements_1v2_wins: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "29")]
    pub utility_count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "30")]
    pub utility_success: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "32")]
    pub flash_count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "33")]
    pub flash_success: ::core::option::Option<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "34")]
    pub mates: ::prost::alloc::vec::Vec<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeepPlayerMatchEvent {
    #[prost(uint32, optional, tag = "1")]
    pub accountid: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "2")]
    pub match_id: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub event_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub event_type: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "5")]
    pub b_playing_ct: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "6")]
    pub user_pos_x: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub user_pos_y: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "12")]
    pub user_pos_z: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "8")]
    pub user_defidx: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "9")]
    pub other_pos_x: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "10")]
    pub other_pos_y: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "13")]
    pub other_pos_z: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "11")]
    pub other_defidx: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "14")]
    pub event_data: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGcServerQuestUpdateData {
    #[prost(message, repeated, tag = "1")]
    pub player_quest_data: ::prost::alloc::vec::Vec<PlayerQuestData>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub binary_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint32, optional, tag = "3")]
    pub mm_game_mode: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "4")]
    pub missionlbsdata: ::core::option::Option<ScoreLeaderboardData>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchmakingGcOperationalStats {
    #[prost(int32, optional, tag = "1")]
    pub packetid: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "2")]
    pub namekeys: ::prost::alloc::vec::Vec<OperationalStatisticDescription>,
    #[prost(message, repeated, tag = "3")]
    pub packets: ::prost::alloc::vec::Vec<OperationalStatisticsPacket>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchmakingGc2ServerConfirm {
    #[prost(uint32, optional, tag = "1")]
    pub token: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub stamp: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub exchange: ::core::option::Option<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Gc2ServerReservationUpdate {
    #[prost(uint32, optional, tag = "1")]
    pub viewers_external_total: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub viewers_external_steam: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchmakingStart {
    #[prost(uint32, repeated, packed = "false", tag = "1")]
    pub account_ids: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub game_type: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "3")]
    pub ticket_data: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "4")]
    pub client_version: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "5")]
    pub tournament_match: ::core::option::Option<TournamentMatchSetup>,
    #[prost(bool, optional, tag = "6")]
    pub prime_only: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "7")]
    pub tv_control: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "8")]
    pub lobby_id: ::core::option::Option<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchmakingStop {
    #[prost(int32, optional, tag = "1")]
    pub abandon: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchmakingClient2ServerPing {
    #[prost(message, repeated, tag = "1")]
    pub gameserverpings: ::prost::alloc::vec::Vec<GameServerPing>,
    #[prost(int32, optional, tag = "2")]
    pub offset_index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub final_batch: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "4")]
    pub data_center_pings: ::prost::alloc::vec::Vec<DataCenterPing>,
    #[prost(uint32, optional, tag = "5")]
    pub max_ping: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag = "6")]
    pub test_token: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchmakingGc2ClientUpdate {
    #[prost(int32, optional, tag = "1")]
    pub matchmaking: ::core::option::Option<i32>,
    #[prost(uint32, repeated, packed = "false", tag = "2")]
    pub waiting_account_id_sessions: ::prost::alloc::vec::Vec<u32>,
    #[prost(string, optional, tag = "3")]
    pub error: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, repeated, packed = "false", tag = "6")]
    pub ongoingmatch_account_id_sessions: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, optional, tag = "7")]
    pub global_stats: ::core::option::Option<GlobalStatistics>,
    #[prost(uint32, repeated, packed = "false", tag = "8")]
    pub failping_account_id_sessions: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "9")]
    pub penalty_account_id_sessions: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "10")]
    pub failready_account_id_sessions: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "11")]
    pub vacbanned_account_id_sessions: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, optional, tag = "12")]
    pub server_ipaddress_mask: ::core::option::Option<IpAddressMask>,
    #[prost(message, repeated, tag = "13")]
    pub notes: ::prost::alloc::vec::Vec<
        c_msg_gcc_strike15_v2_matchmaking_gc2_client_update::Note,
    >,
    #[prost(uint32, repeated, packed = "false", tag = "14")]
    pub penalty_account_id_sessions_green: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "15")]
    pub insufficientlevel_sessions: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "16")]
    pub vsncheck_account_id_sessions: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "17")]
    pub launcher_mismatch_sessions: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "18")]
    pub insecure_account_id_sessions: ::prost::alloc::vec::Vec<u32>,
}
/// Nested message and enum types in `CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate`.
pub mod c_msg_gcc_strike15_v2_matchmaking_gc2_client_update {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Note {
        #[prost(int32, optional, tag = "1")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub region_id: ::core::option::Option<i32>,
        #[prost(float, optional, tag = "3")]
        pub region_r: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "4")]
        pub distance: ::core::option::Option<f32>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDataGccStrike15V2TournamentMatchDraft {
    #[prost(int32, optional, tag = "1")]
    pub event_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub event_stage_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub team_id_0: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub team_id_1: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub maps_count: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub maps_current: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub team_id_start: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "8")]
    pub team_id_veto1: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "9")]
    pub team_id_pickn: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "10")]
    pub drafts: ::prost::alloc::vec::Vec<
        c_data_gcc_strike15_v2_tournament_match_draft::Entry,
    >,
}
/// Nested message and enum types in `CDataGCCStrike15_v2_TournamentMatchDraft`.
pub mod c_data_gcc_strike15_v2_tournament_match_draft {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Entry {
        #[prost(int32, optional, tag = "1")]
        pub mapid: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub team_id_ct: ::core::option::Option<i32>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CPreMatchInfoData {
    #[prost(int32, optional, tag = "1")]
    pub predictions_pct: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "4")]
    pub draft: ::core::option::Option<CDataGccStrike15V2TournamentMatchDraft>,
    #[prost(message, repeated, tag = "5")]
    pub stats: ::prost::alloc::vec::Vec<c_pre_match_info_data::TeamStats>,
    #[prost(int32, repeated, packed = "false", tag = "6")]
    pub wins: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `CPreMatchInfoData`.
pub mod c_pre_match_info_data {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TeamStats {
        #[prost(int32, optional, tag = "1")]
        pub match_info_idxtxt: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub match_info_txt: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "3")]
        pub match_info_teams: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchmakingGc2ServerReserve {
    #[prost(uint32, repeated, packed = "false", tag = "1")]
    pub account_ids: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub game_type: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub match_id: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub server_version: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "18")]
    pub flags: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "5")]
    pub rankings: ::prost::alloc::vec::Vec<PlayerRankingInfo>,
    #[prost(uint64, optional, tag = "6")]
    pub encryption_key: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "7")]
    pub encryption_key_pub: ::core::option::Option<u64>,
    #[prost(uint32, repeated, packed = "false", tag = "8")]
    pub party_ids: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "9")]
    pub whitelist: ::prost::alloc::vec::Vec<IpAddressMask>,
    #[prost(uint64, optional, tag = "10")]
    pub tv_master_steamid: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "11")]
    pub tournament_event: ::core::option::Option<TournamentEvent>,
    #[prost(message, repeated, tag = "12")]
    pub tournament_teams: ::prost::alloc::vec::Vec<TournamentTeam>,
    #[prost(uint32, repeated, packed = "false", tag = "13")]
    pub tournament_casters_account_ids: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint64, optional, tag = "14")]
    pub tv_relay_steamid: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "15")]
    pub pre_match_data: ::core::option::Option<CPreMatchInfoData>,
    #[prost(uint32, optional, tag = "16")]
    pub rtime32_event_start: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "17")]
    pub tv_control: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchmakingServerReservationResponse {
    #[prost(uint64, optional, tag = "1")]
    pub reservationid: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "2")]
    pub reservation: ::core::option::Option<
        CMsgGccStrike15V2MatchmakingGc2ServerReserve,
    >,
    #[prost(string, optional, tag = "3")]
    pub map: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "4")]
    pub gc_reservation_sent: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "5")]
    pub server_version: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "6")]
    pub tv_info: ::core::option::Option<ServerHltvInfo>,
    #[prost(uint32, repeated, packed = "false", tag = "7")]
    pub reward_player_accounts: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "8")]
    pub idle_player_accounts: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub reward_item_attr_def_idx: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub reward_item_attr_value: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "11")]
    pub reward_item_attr_reward_idx: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "12")]
    pub reward_drop_list: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "13")]
    pub tournament_tag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "14")]
    pub legacy_steamdatagram_port: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "17")]
    pub steamdatagram_routing: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag = "15")]
    pub test_token: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "16")]
    pub flags: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchmakingGc2ClientReserve {
    #[prost(uint64, optional, tag = "1")]
    pub serverid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub direct_udp_ip: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub direct_udp_port: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "4")]
    pub reservationid: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "5")]
    pub reservation: ::core::option::Option<
        CMsgGccStrike15V2MatchmakingGc2ServerReserve,
    >,
    #[prost(string, optional, tag = "6")]
    pub map: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "7")]
    pub server_address: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchmakingServerRoundStats {
    #[prost(uint64, optional, tag = "1")]
    pub reservationid: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "2")]
    pub reservation: ::core::option::Option<
        CMsgGccStrike15V2MatchmakingGc2ServerReserve,
    >,
    #[prost(string, optional, tag = "3")]
    pub map: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "4")]
    pub round: ::core::option::Option<i32>,
    #[prost(int32, repeated, packed = "false", tag = "5")]
    pub kills: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed = "false", tag = "6")]
    pub assists: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed = "false", tag = "7")]
    pub deaths: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed = "false", tag = "8")]
    pub scores: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed = "false", tag = "9")]
    pub pings: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, optional, tag = "10")]
    pub round_result: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "11")]
    pub match_result: ::core::option::Option<i32>,
    #[prost(int32, repeated, packed = "false", tag = "12")]
    pub team_scores: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, optional, tag = "13")]
    pub confirm: ::core::option::Option<CMsgGccStrike15V2MatchmakingGc2ServerConfirm>,
    #[prost(int32, optional, tag = "14")]
    pub reservation_stage: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "15")]
    pub match_duration: ::core::option::Option<i32>,
    #[prost(int32, repeated, packed = "false", tag = "16")]
    pub enemy_kills: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed = "false", tag = "17")]
    pub enemy_headshots: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed = "false", tag = "18")]
    pub enemy_3ks: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed = "false", tag = "19")]
    pub enemy_4ks: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed = "false", tag = "20")]
    pub enemy_5ks: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed = "false", tag = "21")]
    pub mvps: ::prost::alloc::vec::Vec<i32>,
    #[prost(uint32, optional, tag = "22")]
    pub spectators_count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "23")]
    pub spectators_count_tv: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "24")]
    pub spectators_count_lnk: ::core::option::Option<u32>,
    #[prost(int32, repeated, packed = "false", tag = "25")]
    pub enemy_kills_agg: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, optional, tag = "26")]
    pub drop_info: ::core::option::Option<
        c_msg_gcc_strike15_v2_matchmaking_server_round_stats::DropInfo,
    >,
    #[prost(bool, optional, tag = "27")]
    pub b_switched_teams: ::core::option::Option<bool>,
    #[prost(int32, repeated, packed = "false", tag = "28")]
    pub enemy_2ks: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed = "false", tag = "29")]
    pub player_spawned: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed = "false", tag = "30")]
    pub team_spawn_count: ::prost::alloc::vec::Vec<i32>,
    #[prost(uint32, optional, tag = "31")]
    pub max_rounds: ::core::option::Option<u32>,
}
/// Nested message and enum types in `CMsgGCCStrike15_v2_MatchmakingServerRoundStats`.
pub mod c_msg_gcc_strike15_v2_matchmaking_server_round_stats {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DropInfo {
        #[prost(uint32, optional, tag = "1")]
        pub account_mvp: ::core::option::Option<u32>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchmakingClient2GcHello {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchmakingGc2ClientHello {
    #[prost(uint32, optional, tag = "1")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "2")]
    pub ongoingmatch: ::core::option::Option<
        CMsgGccStrike15V2MatchmakingGc2ClientReserve,
    >,
    #[prost(message, optional, tag = "3")]
    pub global_stats: ::core::option::Option<GlobalStatistics>,
    #[prost(uint32, optional, tag = "4")]
    pub penalty_seconds: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub penalty_reason: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "6")]
    pub vac_banned: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "7")]
    pub ranking: ::core::option::Option<PlayerRankingInfo>,
    #[prost(message, optional, tag = "8")]
    pub commendation: ::core::option::Option<PlayerCommendationInfo>,
    #[prost(message, optional, tag = "9")]
    pub medals: ::core::option::Option<PlayerMedalsInfo>,
    #[prost(message, optional, tag = "10")]
    pub my_current_event: ::core::option::Option<TournamentEvent>,
    #[prost(message, repeated, tag = "11")]
    pub my_current_event_teams: ::prost::alloc::vec::Vec<TournamentTeam>,
    #[prost(message, optional, tag = "12")]
    pub my_current_team: ::core::option::Option<TournamentTeam>,
    #[prost(message, repeated, tag = "13")]
    pub my_current_event_stages: ::prost::alloc::vec::Vec<TournamentEvent>,
    #[prost(uint32, optional, tag = "14")]
    pub survey_vote: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "15")]
    pub activity: ::core::option::Option<AccountActivity>,
    #[prost(int32, optional, tag = "17")]
    pub player_level: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "18")]
    pub player_cur_xp: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "19")]
    pub player_xp_bonus_flags: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "20")]
    pub rankings: ::prost::alloc::vec::Vec<PlayerRankingInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2AccountPrivacySettings {
    #[prost(message, repeated, tag = "1")]
    pub settings: ::prost::alloc::vec::Vec<
        c_msg_gcc_strike15_v2_account_privacy_settings::Setting,
    >,
}
/// Nested message and enum types in `CMsgGCCStrike15_v2_AccountPrivacySettings`.
pub mod c_msg_gcc_strike15_v2_account_privacy_settings {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Setting {
        #[prost(uint32, optional, tag = "1")]
        pub setting_type: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub setting_value: ::core::option::Option<u32>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchmakingGc2ClientAbandon {
    #[prost(uint32, optional, tag = "1")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "2")]
    pub abandoned_match: ::core::option::Option<
        CMsgGccStrike15V2MatchmakingGc2ClientReserve,
    >,
    #[prost(uint32, optional, tag = "3")]
    pub penalty_seconds: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub penalty_reason: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientGcRankUpdate {
    #[prost(message, repeated, tag = "1")]
    pub rankings: ::prost::alloc::vec::Vec<PlayerRankingInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchmakingOperator2GcBlogUpdate {
    #[prost(string, optional, tag = "1")]
    pub main_post_url: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ServerNotificationForUserPenalty {
    #[prost(uint32, optional, tag = "1")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub reason: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub seconds: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "4")]
    pub communication_cooldown: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientReportPlayer {
    #[prost(uint32, optional, tag = "1")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub rpt_aimbot: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub rpt_wallhack: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub rpt_speedhack: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub rpt_teamharm: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub rpt_textabuse: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub rpt_voiceabuse: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "8")]
    pub match_id: ::core::option::Option<u64>,
    #[prost(bool, optional, tag = "9")]
    pub report_from_demo: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientCommendPlayer {
    #[prost(uint32, optional, tag = "1")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "8")]
    pub match_id: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "9")]
    pub commendation: ::core::option::Option<PlayerCommendationInfo>,
    #[prost(uint32, optional, tag = "10")]
    pub tokens: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientReportServer {
    #[prost(uint32, optional, tag = "1")]
    pub rpt_poorperf: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub rpt_abusivemodels: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub rpt_badmotd: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub rpt_listingabuse: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub rpt_inventoryabuse: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "8")]
    pub match_id: ::core::option::Option<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientReportResponse {
    #[prost(uint64, optional, tag = "1")]
    pub confirmation_id: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub server_ip: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub response_type: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub response_result: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub tokens: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientRequestWatchInfoFriends {
    #[prost(uint32, optional, tag = "1")]
    pub request_id: ::core::option::Option<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "2")]
    pub account_ids: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub serverid: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub matchid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "5")]
    pub client_launcher: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "6")]
    pub data_center_pings: ::prost::alloc::vec::Vec<DataCenterPing>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WatchableMatchInfo {
    #[prost(uint32, optional, tag = "1")]
    pub server_ip: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub tv_port: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub tv_spectators: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub tv_time: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "5")]
    pub tv_watch_password: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint64, optional, tag = "6")]
    pub cl_decryptdata_key: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "7")]
    pub cl_decryptdata_key_pub: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "8")]
    pub game_type: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "9")]
    pub game_mapgroup: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "10")]
    pub game_map: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "11")]
    pub server_id: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "12")]
    pub match_id: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "13")]
    pub reservation_id: ::core::option::Option<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientRequestJoinFriendData {
    #[prost(uint32, optional, tag = "1")]
    pub version: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub join_token: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub join_ipp: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "5")]
    pub res: ::core::option::Option<CMsgGccStrike15V2MatchmakingGc2ClientReserve>,
    #[prost(string, optional, tag = "6")]
    pub errormsg: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientRequestJoinServerData {
    #[prost(uint32, optional, tag = "1")]
    pub version: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub serverid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub server_ip: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub server_port: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "6")]
    pub res: ::core::option::Option<CMsgGccStrike15V2MatchmakingGc2ClientReserve>,
    #[prost(string, optional, tag = "7")]
    pub errormsg: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGcCstrike15V2ClientRequestNewMission {
    #[prost(uint32, optional, tag = "2")]
    pub mission_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub campaign_id: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGcCstrike15V2ClientRedeemMissionReward {
    #[prost(uint32, optional, tag = "1")]
    pub campaign_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub redeem_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub redeemable_balance: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub expected_cost: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGcCstrike15V2Gc2ServerNotifyXpRewarded {
    #[prost(message, repeated, tag = "1")]
    pub xp_progress_data: ::prost::alloc::vec::Vec<XpProgressData>,
    #[prost(uint32, optional, tag = "2")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub current_xp: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub current_level: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub upgraded_defidx: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub operation_points_awarded: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15ClientDeepStats {
    #[prost(uint32, optional, tag = "1")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "2")]
    pub range: ::core::option::Option<
        c_msg_gcc_strike15_client_deep_stats::DeepStatsRange,
    >,
    #[prost(message, repeated, tag = "3")]
    pub matches: ::prost::alloc::vec::Vec<
        c_msg_gcc_strike15_client_deep_stats::DeepStatsMatch,
    >,
}
/// Nested message and enum types in `CMsgGCCStrike15_ClientDeepStats`.
pub mod c_msg_gcc_strike15_client_deep_stats {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DeepStatsRange {
        #[prost(uint32, optional, tag = "1")]
        pub begin: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub end: ::core::option::Option<u32>,
        #[prost(bool, optional, tag = "3")]
        pub frozen: ::core::option::Option<bool>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DeepStatsMatch {
        #[prost(message, optional, tag = "1")]
        pub player: ::core::option::Option<super::DeepPlayerStatsEntry>,
        #[prost(message, repeated, tag = "2")]
        pub events: ::prost::alloc::vec::Vec<super::DeepPlayerMatchEvent>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2WatchInfoUsers {
    #[prost(uint32, optional, tag = "1")]
    pub request_id: ::core::option::Option<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "2")]
    pub account_ids: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag = "3")]
    pub watchable_match_infos: ::prost::alloc::vec::Vec<WatchableMatchInfo>,
    #[prost(uint32, optional, tag = "5")]
    pub extended_timeout: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientRequestPlayersProfile {
    #[prost(uint32, optional, tag = "1")]
    pub request_id_deprecated: ::core::option::Option<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "2")]
    pub account_ids_deprecated: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub request_level: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2PlayersProfile {
    #[prost(uint32, optional, tag = "1")]
    pub request_id: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "2")]
    pub account_profiles: ::prost::alloc::vec::Vec<
        CMsgGccStrike15V2MatchmakingGc2ClientHello,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2PlayerOverwatchCaseUpdate {
    #[prost(uint64, optional, tag = "1")]
    pub caseid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub suspectid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub fractionid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub rpt_aimbot: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub rpt_wallhack: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub rpt_speedhack: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub rpt_teamharm: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub reason: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2PlayerOverwatchCaseAssignment {
    #[prost(uint64, optional, tag = "1")]
    pub caseid: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "2")]
    pub caseurl: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub verdict: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub timestamp: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub throttleseconds: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub suspectid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub fractionid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub numrounds: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub fractionrounds: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "10")]
    pub streakconvictions: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "11")]
    pub reason: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2PlayerOverwatchCaseStatus {
    #[prost(uint64, optional, tag = "1")]
    pub caseid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub statusid: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CClientHeaderOverwatchEvidence {
    #[prost(uint32, optional, tag = "1")]
    pub accountid: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "2")]
    pub caseid: ::core::option::Option<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Gc2ClientTextMsg {
    #[prost(uint32, optional, tag = "1")]
    pub id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub r#type: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub payload: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Client2GcTextMsg {
    #[prost(uint32, optional, tag = "1")]
    pub id: ::core::option::Option<u32>,
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub args: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchEndRunRewardDrops {
    #[prost(message, optional, tag = "3")]
    pub serverinfo: ::core::option::Option<
        CMsgGccStrike15V2MatchmakingServerReservationResponse,
    >,
    #[prost(message, optional, tag = "4")]
    pub match_end_quest_data: ::core::option::Option<CMsgGcServerQuestUpdateData>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CEconItemPreviewDataBlock {
    #[prost(uint32, optional, tag = "1")]
    pub accountid: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "2")]
    pub itemid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub defindex: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub paintindex: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub rarity: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub quality: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub paintwear: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub paintseed: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub killeaterscoretype: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub killeatervalue: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "11")]
    pub customname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "12")]
    pub stickers: ::prost::alloc::vec::Vec<c_econ_item_preview_data_block::Sticker>,
    #[prost(uint32, optional, tag = "13")]
    pub inventory: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "14")]
    pub origin: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "15")]
    pub questid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "16")]
    pub dropreason: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "17")]
    pub musicindex: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "18")]
    pub entindex: ::core::option::Option<i32>,
}
/// Nested message and enum types in `CEconItemPreviewDataBlock`.
pub mod c_econ_item_preview_data_block {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Sticker {
        #[prost(uint32, optional, tag = "1")]
        pub slot: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub sticker_id: ::core::option::Option<u32>,
        #[prost(float, optional, tag = "3")]
        pub wear: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "4")]
        pub scale: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "5")]
        pub rotation: ::core::option::Option<f32>,
        #[prost(uint32, optional, tag = "6")]
        pub tint_id: ::core::option::Option<u32>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchEndRewardDropsNotification {
    #[prost(message, optional, tag = "6")]
    pub iteminfo: ::core::option::Option<CEconItemPreviewDataBlock>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgItemAcknowledged {
    #[prost(message, optional, tag = "1")]
    pub iteminfo: ::core::option::Option<CEconItemPreviewDataBlock>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Client2GcEconPreviewDataBlockRequest {
    #[prost(uint64, optional, tag = "1")]
    pub param_s: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub param_a: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub param_d: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub param_m: ::core::option::Option<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Client2GcEconPreviewDataBlockResponse {
    #[prost(message, optional, tag = "1")]
    pub iteminfo: ::core::option::Option<CEconItemPreviewDataBlock>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchListRequestCurrentLiveGames {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchListRequestLiveGameForUser {
    #[prost(uint32, optional, tag = "1")]
    pub accountid: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchListRequestRecentUserGames {
    #[prost(uint32, optional, tag = "1")]
    pub accountid: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchListRequestTournamentGames {
    #[prost(int32, optional, tag = "1")]
    pub eventid: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchListRequestFullGameInfo {
    #[prost(uint64, optional, tag = "1")]
    pub matchid: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub outcomeid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub token: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDataGccStrike15V2MatchInfo {
    #[prost(uint64, optional, tag = "1")]
    pub matchid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub matchtime: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "3")]
    pub watchablematchinfo: ::core::option::Option<WatchableMatchInfo>,
    #[prost(message, optional, tag = "4")]
    pub roundstats_legacy: ::core::option::Option<
        CMsgGccStrike15V2MatchmakingServerRoundStats,
    >,
    #[prost(message, repeated, tag = "5")]
    pub roundstatsall: ::prost::alloc::vec::Vec<
        CMsgGccStrike15V2MatchmakingServerRoundStats,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDataGccStrike15V2TournamentGroupTeam {
    #[prost(int32, optional, tag = "1")]
    pub team_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub score: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub correctpick: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDataGccStrike15V2TournamentGroup {
    #[prost(uint32, optional, tag = "1")]
    pub groupid: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub desc: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "4")]
    pub picks_deprecated: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "5")]
    pub teams: ::prost::alloc::vec::Vec<CDataGccStrike15V2TournamentGroupTeam>,
    #[prost(int32, repeated, packed = "false", tag = "6")]
    pub stage_ids: ::prost::alloc::vec::Vec<i32>,
    #[prost(uint32, optional, tag = "7")]
    pub picklockuntiltime: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub pickableteams: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub points_per_pick: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "10")]
    pub picks: ::prost::alloc::vec::Vec<c_data_gcc_strike15_v2_tournament_group::Picks>,
}
/// Nested message and enum types in `CDataGCCStrike15_v2_TournamentGroup`.
pub mod c_data_gcc_strike15_v2_tournament_group {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Picks {
        #[prost(int32, repeated, packed = "false", tag = "1")]
        pub pickids: ::prost::alloc::vec::Vec<i32>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDataGccStrike15V2TournamentSection {
    #[prost(uint32, optional, tag = "1")]
    pub sectionid: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub desc: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "4")]
    pub groups: ::prost::alloc::vec::Vec<CDataGccStrike15V2TournamentGroup>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDataGccStrike15V2TournamentInfo {
    #[prost(message, repeated, tag = "1")]
    pub sections: ::prost::alloc::vec::Vec<CDataGccStrike15V2TournamentSection>,
    #[prost(message, optional, tag = "2")]
    pub tournament_event: ::core::option::Option<TournamentEvent>,
    #[prost(message, repeated, tag = "3")]
    pub tournament_teams: ::prost::alloc::vec::Vec<TournamentTeam>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchList {
    #[prost(uint32, optional, tag = "1")]
    pub msgrequestid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub accountid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub servertime: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "4")]
    pub matches: ::prost::alloc::vec::Vec<CDataGccStrike15V2MatchInfo>,
    #[prost(message, repeated, tag = "5")]
    pub streams: ::prost::alloc::vec::Vec<TournamentTeam>,
    #[prost(message, optional, tag = "6")]
    pub tournamentinfo: ::core::option::Option<CDataGccStrike15V2TournamentInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchListTournamentOperatorMgmt {
    #[prost(int32, optional, tag = "1")]
    pub eventid: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "2")]
    pub matches: ::prost::alloc::vec::Vec<CDataGccStrike15V2MatchInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Predictions {
    #[prost(uint32, optional, tag = "1")]
    pub event_id: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "2")]
    pub group_match_team_picks: ::prost::alloc::vec::Vec<
        c_msg_gcc_strike15_v2_predictions::GroupMatchTeamPick,
    >,
}
/// Nested message and enum types in `CMsgGCCStrike15_v2_Predictions`.
pub mod c_msg_gcc_strike15_v2_predictions {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GroupMatchTeamPick {
        #[prost(int32, optional, tag = "1")]
        pub sectionid: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub groupid: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "3")]
        pub index: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "4")]
        pub teamid: ::core::option::Option<i32>,
        #[prost(uint64, optional, tag = "5")]
        pub itemid: ::core::option::Option<u64>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Fantasy {
    #[prost(uint32, optional, tag = "1")]
    pub event_id: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "2")]
    pub teams: ::prost::alloc::vec::Vec<c_msg_gcc_strike15_v2_fantasy::FantasyTeam>,
}
/// Nested message and enum types in `CMsgGCCStrike15_v2_Fantasy`.
pub mod c_msg_gcc_strike15_v2_fantasy {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FantasySlot {
        #[prost(int32, optional, tag = "1")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub pick: ::core::option::Option<i32>,
        #[prost(uint64, optional, tag = "3")]
        pub itemid: ::core::option::Option<u64>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FantasyTeam {
        #[prost(int32, optional, tag = "1")]
        pub sectionid: ::core::option::Option<i32>,
        #[prost(message, repeated, tag = "2")]
        pub slots: ::prost::alloc::vec::Vec<FantasySlot>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CAttributeString {
    #[prost(string, optional, tag = "1")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgCStrike15Welcome {
    #[prost(uint32, optional, tag = "5")]
    pub store_item_hash: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub timeplayedconsecutively: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub time_first_played: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "12")]
    pub last_time_played: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "13")]
    pub last_ip_address: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "18")]
    pub gscookieid: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "19")]
    pub uniqueid: ::core::option::Option<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientVarValueNotificationInfo {
    #[prost(string, optional, tag = "1")]
    pub value_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub value_int: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub server_addr: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub server_port: ::core::option::Option<u32>,
    #[prost(string, repeated, tag = "5")]
    pub choked_blocks: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ServerVarValueNotificationInfo {
    #[prost(uint32, optional, tag = "1")]
    pub accountid: ::core::option::Option<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "2")]
    pub viewangles: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub r#type: ::core::option::Option<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "4")]
    pub userdata: ::prost::alloc::vec::Vec<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2GiftsLeaderboardRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2GiftsLeaderboardResponse {
    #[prost(uint32, optional, tag = "1")]
    pub servertime: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub time_period_seconds: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub total_gifts_given: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub total_givers: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "5")]
    pub entries: ::prost::alloc::vec::Vec<
        c_msg_gcc_strike15_v2_gifts_leaderboard_response::GiftLeaderboardEntry,
    >,
}
/// Nested message and enum types in `CMsgGCCStrike15_v2_GiftsLeaderboardResponse`.
pub mod c_msg_gcc_strike15_v2_gifts_leaderboard_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GiftLeaderboardEntry {
        #[prost(uint32, optional, tag = "1")]
        pub accountid: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub gifts: ::core::option::Option<u32>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientSubmitSurveyVote {
    #[prost(uint32, optional, tag = "1")]
    pub survey_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub vote: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Server2GcClientValidate {
    #[prost(uint32, optional, tag = "1")]
    pub accountid: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Gc2ClientTournamentInfo {
    #[prost(uint32, optional, tag = "1")]
    pub eventid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub stageid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub game_type: ::core::option::Option<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "4")]
    pub teamids: ::prost::alloc::vec::Vec<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsoEconCoupon {
    #[prost(uint32, optional, tag = "1")]
    pub entryid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub defidx: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag = "3")]
    pub expiration_date: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsoQuestProgress {
    #[prost(uint32, optional, tag = "1")]
    pub questid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub points_remaining: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub bonus_points: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsoAccountSeasonalOperation {
    #[prost(uint32, optional, tag = "1")]
    pub season_value: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub tier_unlocked: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub premium_tiers: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub mission_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub missions_completed: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub redeemable_balance: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub season_pass_time: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsoAccountRecurringSubscription {
    #[prost(uint32, optional, tag = "1")]
    pub time_next_cycle: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub time_initiated: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsoPersonaDataPublic {
    #[prost(int32, optional, tag = "1")]
    pub player_level: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub commendation: ::core::option::Option<PlayerCommendationInfo>,
    #[prost(bool, optional, tag = "3")]
    pub elevated_state: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGcGlobalGameSubscribe {
    #[prost(uint64, optional, tag = "1")]
    pub ticket: ::core::option::Option<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGcGlobalGameUnsubscribe {
    #[prost(int32, optional, tag = "1")]
    pub timeleft: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGcGlobalGamePlay {
    #[prost(uint64, optional, tag = "1")]
    pub ticket: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "2")]
    pub gametimems: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub msperpoint: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2AcknowledgePenalty {
    #[prost(int32, optional, tag = "1")]
    pub acknowledged: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Client2GcRequestPrestigeCoin {
    #[prost(uint32, optional, tag = "1")]
    pub defindex: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "2")]
    pub upgradeid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub hours: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub prestigetime: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Client2GcStreamUnlock {
    #[prost(uint64, optional, tag = "1")]
    pub ticket: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "2")]
    pub os: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientToGcRequestElevate {
    #[prost(uint32, optional, tag = "1")]
    pub stage: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientToGcChat {
    #[prost(uint64, optional, tag = "1")]
    pub match_id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "2")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2GcToClientChat {
    #[prost(uint32, optional, tag = "1")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientAuthKeyCode {
    #[prost(uint32, optional, tag = "1")]
    pub eventid: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub code: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15GotvSyncPacket {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<CEngineGotvSyncPacket>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerDecalDigitalSignature {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub signature: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint32, optional, tag = "2")]
    pub accountid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub rtime: ::core::option::Option<u32>,
    #[prost(float, repeated, packed = "false", tag = "4")]
    pub endpos: ::prost::alloc::vec::Vec<f32>,
    #[prost(float, repeated, packed = "false", tag = "5")]
    pub startpos: ::prost::alloc::vec::Vec<f32>,
    #[prost(float, repeated, packed = "false", tag = "6")]
    pub right: ::prost::alloc::vec::Vec<f32>,
    #[prost(uint32, optional, tag = "7")]
    pub tx_defidx: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "8")]
    pub entindex: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "9")]
    pub hitbox: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "10")]
    pub creationtime: ::core::option::Option<f32>,
    #[prost(uint32, optional, tag = "11")]
    pub equipslot: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "12")]
    pub trace_id: ::core::option::Option<u32>,
    #[prost(float, repeated, packed = "false", tag = "13")]
    pub normal: ::prost::alloc::vec::Vec<f32>,
    #[prost(uint32, optional, tag = "14")]
    pub tint_id: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientPlayerDecalSign {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<PlayerDecalDigitalSignature>,
    #[prost(uint64, optional, tag = "2")]
    pub itemid: ::core::option::Option<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientLogonFatalError {
    #[prost(uint32, optional, tag = "1")]
    pub errorcode: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "2")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub country: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientPollState {
    #[prost(uint32, optional, tag = "1")]
    pub pollid: ::core::option::Option<u32>,
    #[prost(string, repeated, tag = "2")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, repeated, packed = "false", tag = "3")]
    pub values: ::prost::alloc::vec::Vec<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2PartyRegister {
    #[prost(uint32, optional, tag = "1")]
    pub id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub ver: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub apr: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub ark: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub nby: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub grp: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub slots: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub launcher: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub game_type: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2PartySearch {
    #[prost(uint32, optional, tag = "1")]
    pub ver: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub apr: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub ark: ::core::option::Option<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "4")]
    pub grps: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub launcher: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub game_type: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2PartySearchResults {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<
        c_msg_gcc_strike15_v2_party_search_results::Entry,
    >,
}
/// Nested message and enum types in `CMsgGCCStrike15_v2_Party_SearchResults`.
pub mod c_msg_gcc_strike15_v2_party_search_results {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Entry {
        #[prost(uint32, optional, tag = "1")]
        pub id: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub grp: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "3")]
        pub game_type: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "4")]
        pub apr: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "5")]
        pub ark: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "6")]
        pub loc: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "7")]
        pub accountid: ::core::option::Option<u32>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2PartyInvite {
    #[prost(uint32, optional, tag = "1")]
    pub accountid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub lobbyid: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2AccountRequestCoPlays {
    #[prost(message, repeated, tag = "1")]
    pub players: ::prost::alloc::vec::Vec<
        c_msg_gcc_strike15_v2_account_request_co_plays::Player,
    >,
    #[prost(uint32, optional, tag = "2")]
    pub servertime: ::core::option::Option<u32>,
}
/// Nested message and enum types in `CMsgGCCStrike15_v2_Account_RequestCoPlays`.
pub mod c_msg_gcc_strike15_v2_account_request_co_plays {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Player {
        #[prost(uint32, optional, tag = "1")]
        pub accountid: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub rtcoplay: ::core::option::Option<u32>,
        #[prost(bool, optional, tag = "3")]
        pub online: ::core::option::Option<bool>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientToGcRequestTicket {
    #[prost(fixed64, optional, tag = "1")]
    pub authorized_steam_id: ::core::option::Option<u64>,
    #[prost(fixed32, optional, tag = "2")]
    pub authorized_public_ip: ::core::option::Option<u32>,
    #[prost(fixed64, optional, tag = "3")]
    pub gameserver_steam_id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "5")]
    pub gameserver_sdr_routing: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGcToClientSteamDatagramTicket {
    #[prost(bytes = "vec", optional, tag = "16")]
    pub serialized_ticket: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientRequestOffers {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientRequestSouvenir {
    #[prost(uint64, optional, tag = "1")]
    pub itemid: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub matchid: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub eventid: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientAccountBalance {
    #[prost(uint64, optional, tag = "1")]
    pub amount: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "2")]
    pub url: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientPartyJoinRelay {
    #[prost(uint32, optional, tag = "1")]
    pub accountid: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "2")]
    pub lobbyid: ::core::option::Option<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientPartyWarning {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<
        c_msg_gcc_strike15_v2_client_party_warning::Entry,
    >,
}
/// Nested message and enum types in `CMsgGCCStrike15_v2_ClientPartyWarning`.
pub mod c_msg_gcc_strike15_v2_client_party_warning {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Entry {
        #[prost(uint32, optional, tag = "1")]
        pub accountid: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub warntype: ::core::option::Option<u32>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2SetEventFavorite {
    #[prost(uint64, optional, tag = "1")]
    pub eventid: ::core::option::Option<u64>,
    #[prost(bool, optional, tag = "2")]
    pub is_favorite: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2GetEventFavoritesRequest {
    #[prost(bool, optional, tag = "1")]
    pub all_events: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2GetEventFavoritesResponse {
    #[prost(bool, optional, tag = "1")]
    pub all_events: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "2")]
    pub json_favorites: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub json_featured: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientPerfReport {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<
        c_msg_gcc_strike15_v2_client_perf_report::Entry,
    >,
}
/// Nested message and enum types in `CMsgGCCStrike15_v2_ClientPerfReport`.
pub mod c_msg_gcc_strike15_v2_client_perf_report {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Entry {
        #[prost(uint32, optional, tag = "1")]
        pub perfcounter: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub length: ::core::option::Option<u32>,
        #[prost(bytes = "vec", optional, tag = "3")]
        pub reference: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes = "vec", optional, tag = "4")]
        pub actual: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(uint32, optional, tag = "5")]
        pub sourceid: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "6")]
        pub status: ::core::option::Option<u32>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CvDiagnostic {
    #[prost(uint32, optional, tag = "1")]
    pub id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub extended: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub value: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "4")]
    pub string_value: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientReportValidation {
    #[prost(string, optional, tag = "1")]
    pub file_report: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub command_line: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub total_files: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub internal_error: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub trust_time: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub count_pending: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub count_completed: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub process_id: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "9")]
    pub osversion: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "10")]
    pub clientreportversion: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "11")]
    pub status_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "12")]
    pub diagnostic1: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "13")]
    pub diagnostic2: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "14")]
    pub diagnostic3: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "15")]
    pub last_launch_data: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "16")]
    pub report_count: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "17")]
    pub client_time: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "18")]
    pub diagnostic4: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "19")]
    pub diagnostic5: ::core::option::Option<u64>,
    #[prost(message, repeated, tag = "20")]
    pub diagnostics: ::prost::alloc::vec::Vec<CvDiagnostic>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Gc2ClientRefuseSecureMode {
    #[prost(string, optional, tag = "1")]
    pub file_report: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "2")]
    pub offer_insecure_mode: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "3")]
    pub offer_secure_mode: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "4")]
    pub show_unsigned_ui: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "5")]
    pub kick_user: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "6")]
    pub show_trusted_ui: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "7")]
    pub show_warning_not_trusted: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "8")]
    pub show_warning_not_trusted_2: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "9")]
    pub files_prevented_trusted: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Gc2ClientRequestValidation {
    #[prost(bool, optional, tag = "1")]
    pub full_report: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "2")]
    pub module: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Gc2ClientInitSystem {
    #[prost(bool, optional, tag = "1")]
    pub load: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub outputname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub key_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "5")]
    pub sha_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int32, optional, tag = "6")]
    pub cookie: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "7")]
    pub manifest: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "8")]
    pub system_package: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "9")]
    pub load_system: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Gc2ClientInitSystemResponse {
    #[prost(bool, optional, tag = "1")]
    pub success: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "2")]
    pub diagnostic: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub sha_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int32, optional, tag = "4")]
    pub response: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub error_code1: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub error_code2: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "7")]
    pub handle: ::core::option::Option<i64>,
    #[prost(
        enumeration = "EInitSystemResult",
        optional,
        tag = "8",
        default = "KEInitSystemResultInvalid"
    )]
    pub einit_result: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "9")]
    pub aux_system1: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "10")]
    pub aux_system2: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ECsgoGcMsg {
    KEMsgGccStrike15V2Base = 9100,
    KEMsgGccStrike15V2MatchmakingStart = 9101,
    KEMsgGccStrike15V2MatchmakingStop = 9102,
    KEMsgGccStrike15V2MatchmakingClient2ServerPing = 9103,
    KEMsgGccStrike15V2MatchmakingGc2ClientUpdate = 9104,
    KEMsgGccStrike15V2MatchmakingServerReservationResponse = 9106,
    KEMsgGccStrike15V2MatchmakingGc2ClientReserve = 9107,
    KEMsgGccStrike15V2MatchmakingClient2GcHello = 9109,
    KEMsgGccStrike15V2MatchmakingGc2ClientHello = 9110,
    KEMsgGccStrike15V2MatchmakingGc2ClientAbandon = 9112,
    KEMsgGccStrike15V2MatchmakingGcOperationalStats = 9115,
    KEMsgGccStrike15V2MatchmakingOperator2GcBlogUpdate = 9117,
    KEMsgGccStrike15V2ServerNotificationForUserPenalty = 9118,
    KEMsgGccStrike15V2ClientReportPlayer = 9119,
    KEMsgGccStrike15V2ClientReportServer = 9120,
    KEMsgGccStrike15V2ClientCommendPlayer = 9121,
    KEMsgGccStrike15V2ClientReportResponse = 9122,
    KEMsgGccStrike15V2ClientCommendPlayerQuery = 9123,
    KEMsgGccStrike15V2ClientCommendPlayerQueryResponse = 9124,
    KEMsgGccStrike15V2WatchInfoUsers = 9126,
    KEMsgGccStrike15V2ClientRequestPlayersProfile = 9127,
    KEMsgGccStrike15V2PlayersProfile = 9128,
    KEMsgGccStrike15V2PlayerOverwatchCaseUpdate = 9131,
    KEMsgGccStrike15V2PlayerOverwatchCaseAssignment = 9132,
    KEMsgGccStrike15V2PlayerOverwatchCaseStatus = 9133,
    KEMsgGccStrike15V2Gc2ClientTextMsg = 9134,
    KEMsgGccStrike15V2Client2GcTextMsg = 9135,
    KEMsgGccStrike15V2MatchEndRunRewardDrops = 9136,
    KEMsgGccStrike15V2MatchEndRewardDropsNotification = 9137,
    KEMsgGccStrike15V2ClientRequestWatchInfoFriends2 = 9138,
    KEMsgGccStrike15V2MatchList = 9139,
    KEMsgGccStrike15V2MatchListRequestCurrentLiveGames = 9140,
    KEMsgGccStrike15V2MatchListRequestRecentUserGames = 9141,
    KEMsgGccStrike15V2Gc2ServerReservationUpdate = 9142,
    KEMsgGccStrike15V2ClientVarValueNotificationInfo = 9144,
    KEMsgGccStrike15V2MatchListRequestTournamentGames = 9146,
    KEMsgGccStrike15V2MatchListRequestFullGameInfo = 9147,
    KEMsgGccStrike15V2GiftsLeaderboardRequest = 9148,
    KEMsgGccStrike15V2GiftsLeaderboardResponse = 9149,
    KEMsgGccStrike15V2ServerVarValueNotificationInfo = 9150,
    KEMsgGccStrike15V2ClientSubmitSurveyVote = 9152,
    KEMsgGccStrike15V2Server2GcClientValidate = 9153,
    KEMsgGccStrike15V2MatchListRequestLiveGameForUser = 9154,
    KEMsgGccStrike15V2Client2GcEconPreviewDataBlockRequest = 9156,
    KEMsgGccStrike15V2Client2GcEconPreviewDataBlockResponse = 9157,
    KEMsgGccStrike15V2AccountPrivacySettings = 9158,
    KEMsgGccStrike15V2SetMyActivityInfo = 9159,
    KEMsgGccStrike15V2MatchListRequestTournamentPredictions = 9160,
    KEMsgGccStrike15V2MatchListUploadTournamentPredictions = 9161,
    KEMsgGccStrike15V2DraftSummary = 9162,
    KEMsgGccStrike15V2ClientRequestJoinFriendData = 9163,
    KEMsgGccStrike15V2ClientRequestJoinServerData = 9164,
    KEMsgGccStrike15V2ClientRequestNewMission = 9165,
    KEMsgGccStrike15V2Gc2ClientTournamentInfo = 9167,
    KEMsgGcGlobalGameSubscribe = 9168,
    KEMsgGcGlobalGameUnsubscribe = 9169,
    KEMsgGcGlobalGamePlay = 9170,
    KEMsgGccStrike15V2AcknowledgePenalty = 9171,
    KEMsgGccStrike15V2Client2GcRequestPrestigeCoin = 9172,
    KEMsgGccStrike15V2Gc2ClientGlobalStats = 9173,
    KEMsgGccStrike15V2Client2GcStreamUnlock = 9174,
    KEMsgGccStrike15V2FantasyRequestClientData = 9175,
    KEMsgGccStrike15V2FantasyUpdateClientData = 9176,
    KEMsgGccStrike15V2GcToClientSteamdatagramTicket = 9177,
    KEMsgGccStrike15V2ClientToGcRequestTicket = 9178,
    KEMsgGccStrike15V2ClientToGcRequestElevate = 9179,
    KEMsgGccStrike15V2GlobalChat = 9180,
    KEMsgGccStrike15V2GlobalChatSubscribe = 9181,
    KEMsgGccStrike15V2GlobalChatUnsubscribe = 9182,
    KEMsgGccStrike15V2ClientAuthKeyCode = 9183,
    KEMsgGccStrike15V2GotvSyncPacket = 9184,
    KEMsgGccStrike15V2ClientPlayerDecalSign = 9185,
    KEMsgGccStrike15V2ClientLogonFatalError = 9187,
    KEMsgGccStrike15V2ClientPollState = 9188,
    KEMsgGccStrike15V2PartyRegister = 9189,
    KEMsgGccStrike15V2PartyUnregister = 9190,
    KEMsgGccStrike15V2PartySearch = 9191,
    KEMsgGccStrike15V2PartyInvite = 9192,
    KEMsgGccStrike15V2AccountRequestCoPlays = 9193,
    KEMsgGccStrike15V2ClientGcRankUpdate = 9194,
    KEMsgGccStrike15V2ClientRequestOffers = 9195,
    KEMsgGccStrike15V2ClientAccountBalance = 9196,
    KEMsgGccStrike15V2ClientPartyJoinRelay = 9197,
    KEMsgGccStrike15V2ClientPartyWarning = 9198,
    KEMsgGccStrike15V2SetEventFavorite = 9200,
    KEMsgGccStrike15V2GetEventFavoritesRequest = 9201,
    KEMsgGccStrike15V2ClientPerfReport = 9202,
    KEMsgGccStrike15V2GetEventFavoritesResponse = 9203,
    KEMsgGccStrike15V2ClientRequestSouvenir = 9204,
    KEMsgGccStrike15V2ClientReportValidation = 9205,
    KEMsgGccStrike15V2Gc2ClientRefuseSecureMode = 9206,
    KEMsgGccStrike15V2Gc2ClientRequestValidation = 9207,
    KEMsgGccStrike15V2ClientRedeemMissionReward = 9209,
    KEMsgGccStrike15ClientDeepStats = 9210,
    KEMsgGccStrike15StartAgreementSessionInGame = 9211,
    KEMsgGccStrike15V2Gc2ClientInitSystem = 9212,
    KEMsgGccStrike15V2Gc2ClientInitSystemResponse = 9213,
    KEMsgGccStrike15V2PrivateQueues = 9214,
    KEMsgGccStrike15V2MatchListTournamentOperatorMgmt = 9215,
}
impl ECsgoGcMsg {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ECsgoGcMsg::KEMsgGccStrike15V2Base => "k_EMsgGCCStrike15_v2_Base",
            ECsgoGcMsg::KEMsgGccStrike15V2MatchmakingStart => {
                "k_EMsgGCCStrike15_v2_MatchmakingStart"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2MatchmakingStop => {
                "k_EMsgGCCStrike15_v2_MatchmakingStop"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2MatchmakingClient2ServerPing => {
                "k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2MatchmakingGc2ClientUpdate => {
                "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2MatchmakingServerReservationResponse => {
                "k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2MatchmakingGc2ClientReserve => {
                "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2MatchmakingClient2GcHello => {
                "k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2MatchmakingGc2ClientHello => {
                "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2MatchmakingGc2ClientAbandon => {
                "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2MatchmakingGcOperationalStats => {
                "k_EMsgGCCStrike15_v2_MatchmakingGCOperationalStats"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2MatchmakingOperator2GcBlogUpdate => {
                "k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ServerNotificationForUserPenalty => {
                "k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ClientReportPlayer => {
                "k_EMsgGCCStrike15_v2_ClientReportPlayer"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ClientReportServer => {
                "k_EMsgGCCStrike15_v2_ClientReportServer"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ClientCommendPlayer => {
                "k_EMsgGCCStrike15_v2_ClientCommendPlayer"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ClientReportResponse => {
                "k_EMsgGCCStrike15_v2_ClientReportResponse"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ClientCommendPlayerQuery => {
                "k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ClientCommendPlayerQueryResponse => {
                "k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2WatchInfoUsers => {
                "k_EMsgGCCStrike15_v2_WatchInfoUsers"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ClientRequestPlayersProfile => {
                "k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2PlayersProfile => {
                "k_EMsgGCCStrike15_v2_PlayersProfile"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2PlayerOverwatchCaseUpdate => {
                "k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2PlayerOverwatchCaseAssignment => {
                "k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2PlayerOverwatchCaseStatus => {
                "k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2Gc2ClientTextMsg => {
                "k_EMsgGCCStrike15_v2_GC2ClientTextMsg"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2Client2GcTextMsg => {
                "k_EMsgGCCStrike15_v2_Client2GCTextMsg"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2MatchEndRunRewardDrops => {
                "k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2MatchEndRewardDropsNotification => {
                "k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ClientRequestWatchInfoFriends2 => {
                "k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2MatchList => "k_EMsgGCCStrike15_v2_MatchList",
            ECsgoGcMsg::KEMsgGccStrike15V2MatchListRequestCurrentLiveGames => {
                "k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2MatchListRequestRecentUserGames => {
                "k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2Gc2ServerReservationUpdate => {
                "k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ClientVarValueNotificationInfo => {
                "k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2MatchListRequestTournamentGames => {
                "k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2MatchListRequestFullGameInfo => {
                "k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2GiftsLeaderboardRequest => {
                "k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2GiftsLeaderboardResponse => {
                "k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ServerVarValueNotificationInfo => {
                "k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ClientSubmitSurveyVote => {
                "k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2Server2GcClientValidate => {
                "k_EMsgGCCStrike15_v2_Server2GCClientValidate"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2MatchListRequestLiveGameForUser => {
                "k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2Client2GcEconPreviewDataBlockRequest => {
                "k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2Client2GcEconPreviewDataBlockResponse => {
                "k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2AccountPrivacySettings => {
                "k_EMsgGCCStrike15_v2_AccountPrivacySettings"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2SetMyActivityInfo => {
                "k_EMsgGCCStrike15_v2_SetMyActivityInfo"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2MatchListRequestTournamentPredictions => {
                "k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2MatchListUploadTournamentPredictions => {
                "k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2DraftSummary => {
                "k_EMsgGCCStrike15_v2_DraftSummary"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ClientRequestJoinFriendData => {
                "k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ClientRequestJoinServerData => {
                "k_EMsgGCCStrike15_v2_ClientRequestJoinServerData"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ClientRequestNewMission => {
                "k_EMsgGCCStrike15_v2_ClientRequestNewMission"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2Gc2ClientTournamentInfo => {
                "k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo"
            }
            ECsgoGcMsg::KEMsgGcGlobalGameSubscribe => "k_EMsgGC_GlobalGame_Subscribe",
            ECsgoGcMsg::KEMsgGcGlobalGameUnsubscribe => "k_EMsgGC_GlobalGame_Unsubscribe",
            ECsgoGcMsg::KEMsgGcGlobalGamePlay => "k_EMsgGC_GlobalGame_Play",
            ECsgoGcMsg::KEMsgGccStrike15V2AcknowledgePenalty => {
                "k_EMsgGCCStrike15_v2_AcknowledgePenalty"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2Client2GcRequestPrestigeCoin => {
                "k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2Gc2ClientGlobalStats => {
                "k_EMsgGCCStrike15_v2_GC2ClientGlobalStats"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2Client2GcStreamUnlock => {
                "k_EMsgGCCStrike15_v2_Client2GCStreamUnlock"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2FantasyRequestClientData => {
                "k_EMsgGCCStrike15_v2_FantasyRequestClientData"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2FantasyUpdateClientData => {
                "k_EMsgGCCStrike15_v2_FantasyUpdateClientData"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2GcToClientSteamdatagramTicket => {
                "k_EMsgGCCStrike15_v2_GCToClientSteamdatagramTicket"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ClientToGcRequestTicket => {
                "k_EMsgGCCStrike15_v2_ClientToGCRequestTicket"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ClientToGcRequestElevate => {
                "k_EMsgGCCStrike15_v2_ClientToGCRequestElevate"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2GlobalChat => "k_EMsgGCCStrike15_v2_GlobalChat",
            ECsgoGcMsg::KEMsgGccStrike15V2GlobalChatSubscribe => {
                "k_EMsgGCCStrike15_v2_GlobalChat_Subscribe"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2GlobalChatUnsubscribe => {
                "k_EMsgGCCStrike15_v2_GlobalChat_Unsubscribe"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ClientAuthKeyCode => {
                "k_EMsgGCCStrike15_v2_ClientAuthKeyCode"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2GotvSyncPacket => {
                "k_EMsgGCCStrike15_v2_GotvSyncPacket"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ClientPlayerDecalSign => {
                "k_EMsgGCCStrike15_v2_ClientPlayerDecalSign"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ClientLogonFatalError => {
                "k_EMsgGCCStrike15_v2_ClientLogonFatalError"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ClientPollState => {
                "k_EMsgGCCStrike15_v2_ClientPollState"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2PartyRegister => {
                "k_EMsgGCCStrike15_v2_Party_Register"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2PartyUnregister => {
                "k_EMsgGCCStrike15_v2_Party_Unregister"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2PartySearch => {
                "k_EMsgGCCStrike15_v2_Party_Search"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2PartyInvite => {
                "k_EMsgGCCStrike15_v2_Party_Invite"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2AccountRequestCoPlays => {
                "k_EMsgGCCStrike15_v2_Account_RequestCoPlays"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ClientGcRankUpdate => {
                "k_EMsgGCCStrike15_v2_ClientGCRankUpdate"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ClientRequestOffers => {
                "k_EMsgGCCStrike15_v2_ClientRequestOffers"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ClientAccountBalance => {
                "k_EMsgGCCStrike15_v2_ClientAccountBalance"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ClientPartyJoinRelay => {
                "k_EMsgGCCStrike15_v2_ClientPartyJoinRelay"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ClientPartyWarning => {
                "k_EMsgGCCStrike15_v2_ClientPartyWarning"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2SetEventFavorite => {
                "k_EMsgGCCStrike15_v2_SetEventFavorite"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2GetEventFavoritesRequest => {
                "k_EMsgGCCStrike15_v2_GetEventFavorites_Request"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ClientPerfReport => {
                "k_EMsgGCCStrike15_v2_ClientPerfReport"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2GetEventFavoritesResponse => {
                "k_EMsgGCCStrike15_v2_GetEventFavorites_Response"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ClientRequestSouvenir => {
                "k_EMsgGCCStrike15_v2_ClientRequestSouvenir"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ClientReportValidation => {
                "k_EMsgGCCStrike15_v2_ClientReportValidation"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2Gc2ClientRefuseSecureMode => {
                "k_EMsgGCCStrike15_v2_GC2ClientRefuseSecureMode"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2Gc2ClientRequestValidation => {
                "k_EMsgGCCStrike15_v2_GC2ClientRequestValidation"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2ClientRedeemMissionReward => {
                "k_EMsgGCCStrike15_v2_ClientRedeemMissionReward"
            }
            ECsgoGcMsg::KEMsgGccStrike15ClientDeepStats => {
                "k_EMsgGCCStrike15_ClientDeepStats"
            }
            ECsgoGcMsg::KEMsgGccStrike15StartAgreementSessionInGame => {
                "k_EMsgGCCStrike15_StartAgreementSessionInGame"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2Gc2ClientInitSystem => {
                "k_EMsgGCCStrike15_v2_GC2ClientInitSystem"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2Gc2ClientInitSystemResponse => {
                "k_EMsgGCCStrike15_v2_GC2ClientInitSystem_Response"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2PrivateQueues => {
                "k_EMsgGCCStrike15_v2_PrivateQueues"
            }
            ECsgoGcMsg::KEMsgGccStrike15V2MatchListTournamentOperatorMgmt => {
                "k_EMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_EMsgGCCStrike15_v2_Base" => Some(Self::KEMsgGccStrike15V2Base),
            "k_EMsgGCCStrike15_v2_MatchmakingStart" => {
                Some(Self::KEMsgGccStrike15V2MatchmakingStart)
            }
            "k_EMsgGCCStrike15_v2_MatchmakingStop" => {
                Some(Self::KEMsgGccStrike15V2MatchmakingStop)
            }
            "k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing" => {
                Some(Self::KEMsgGccStrike15V2MatchmakingClient2ServerPing)
            }
            "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate" => {
                Some(Self::KEMsgGccStrike15V2MatchmakingGc2ClientUpdate)
            }
            "k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse" => {
                Some(Self::KEMsgGccStrike15V2MatchmakingServerReservationResponse)
            }
            "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve" => {
                Some(Self::KEMsgGccStrike15V2MatchmakingGc2ClientReserve)
            }
            "k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello" => {
                Some(Self::KEMsgGccStrike15V2MatchmakingClient2GcHello)
            }
            "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello" => {
                Some(Self::KEMsgGccStrike15V2MatchmakingGc2ClientHello)
            }
            "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon" => {
                Some(Self::KEMsgGccStrike15V2MatchmakingGc2ClientAbandon)
            }
            "k_EMsgGCCStrike15_v2_MatchmakingGCOperationalStats" => {
                Some(Self::KEMsgGccStrike15V2MatchmakingGcOperationalStats)
            }
            "k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate" => {
                Some(Self::KEMsgGccStrike15V2MatchmakingOperator2GcBlogUpdate)
            }
            "k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty" => {
                Some(Self::KEMsgGccStrike15V2ServerNotificationForUserPenalty)
            }
            "k_EMsgGCCStrike15_v2_ClientReportPlayer" => {
                Some(Self::KEMsgGccStrike15V2ClientReportPlayer)
            }
            "k_EMsgGCCStrike15_v2_ClientReportServer" => {
                Some(Self::KEMsgGccStrike15V2ClientReportServer)
            }
            "k_EMsgGCCStrike15_v2_ClientCommendPlayer" => {
                Some(Self::KEMsgGccStrike15V2ClientCommendPlayer)
            }
            "k_EMsgGCCStrike15_v2_ClientReportResponse" => {
                Some(Self::KEMsgGccStrike15V2ClientReportResponse)
            }
            "k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery" => {
                Some(Self::KEMsgGccStrike15V2ClientCommendPlayerQuery)
            }
            "k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse" => {
                Some(Self::KEMsgGccStrike15V2ClientCommendPlayerQueryResponse)
            }
            "k_EMsgGCCStrike15_v2_WatchInfoUsers" => {
                Some(Self::KEMsgGccStrike15V2WatchInfoUsers)
            }
            "k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile" => {
                Some(Self::KEMsgGccStrike15V2ClientRequestPlayersProfile)
            }
            "k_EMsgGCCStrike15_v2_PlayersProfile" => {
                Some(Self::KEMsgGccStrike15V2PlayersProfile)
            }
            "k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate" => {
                Some(Self::KEMsgGccStrike15V2PlayerOverwatchCaseUpdate)
            }
            "k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment" => {
                Some(Self::KEMsgGccStrike15V2PlayerOverwatchCaseAssignment)
            }
            "k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus" => {
                Some(Self::KEMsgGccStrike15V2PlayerOverwatchCaseStatus)
            }
            "k_EMsgGCCStrike15_v2_GC2ClientTextMsg" => {
                Some(Self::KEMsgGccStrike15V2Gc2ClientTextMsg)
            }
            "k_EMsgGCCStrike15_v2_Client2GCTextMsg" => {
                Some(Self::KEMsgGccStrike15V2Client2GcTextMsg)
            }
            "k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops" => {
                Some(Self::KEMsgGccStrike15V2MatchEndRunRewardDrops)
            }
            "k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification" => {
                Some(Self::KEMsgGccStrike15V2MatchEndRewardDropsNotification)
            }
            "k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2" => {
                Some(Self::KEMsgGccStrike15V2ClientRequestWatchInfoFriends2)
            }
            "k_EMsgGCCStrike15_v2_MatchList" => Some(Self::KEMsgGccStrike15V2MatchList),
            "k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames" => {
                Some(Self::KEMsgGccStrike15V2MatchListRequestCurrentLiveGames)
            }
            "k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames" => {
                Some(Self::KEMsgGccStrike15V2MatchListRequestRecentUserGames)
            }
            "k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate" => {
                Some(Self::KEMsgGccStrike15V2Gc2ServerReservationUpdate)
            }
            "k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo" => {
                Some(Self::KEMsgGccStrike15V2ClientVarValueNotificationInfo)
            }
            "k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames" => {
                Some(Self::KEMsgGccStrike15V2MatchListRequestTournamentGames)
            }
            "k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo" => {
                Some(Self::KEMsgGccStrike15V2MatchListRequestFullGameInfo)
            }
            "k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest" => {
                Some(Self::KEMsgGccStrike15V2GiftsLeaderboardRequest)
            }
            "k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse" => {
                Some(Self::KEMsgGccStrike15V2GiftsLeaderboardResponse)
            }
            "k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo" => {
                Some(Self::KEMsgGccStrike15V2ServerVarValueNotificationInfo)
            }
            "k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote" => {
                Some(Self::KEMsgGccStrike15V2ClientSubmitSurveyVote)
            }
            "k_EMsgGCCStrike15_v2_Server2GCClientValidate" => {
                Some(Self::KEMsgGccStrike15V2Server2GcClientValidate)
            }
            "k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser" => {
                Some(Self::KEMsgGccStrike15V2MatchListRequestLiveGameForUser)
            }
            "k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest" => {
                Some(Self::KEMsgGccStrike15V2Client2GcEconPreviewDataBlockRequest)
            }
            "k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse" => {
                Some(Self::KEMsgGccStrike15V2Client2GcEconPreviewDataBlockResponse)
            }
            "k_EMsgGCCStrike15_v2_AccountPrivacySettings" => {
                Some(Self::KEMsgGccStrike15V2AccountPrivacySettings)
            }
            "k_EMsgGCCStrike15_v2_SetMyActivityInfo" => {
                Some(Self::KEMsgGccStrike15V2SetMyActivityInfo)
            }
            "k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions" => {
                Some(Self::KEMsgGccStrike15V2MatchListRequestTournamentPredictions)
            }
            "k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions" => {
                Some(Self::KEMsgGccStrike15V2MatchListUploadTournamentPredictions)
            }
            "k_EMsgGCCStrike15_v2_DraftSummary" => {
                Some(Self::KEMsgGccStrike15V2DraftSummary)
            }
            "k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData" => {
                Some(Self::KEMsgGccStrike15V2ClientRequestJoinFriendData)
            }
            "k_EMsgGCCStrike15_v2_ClientRequestJoinServerData" => {
                Some(Self::KEMsgGccStrike15V2ClientRequestJoinServerData)
            }
            "k_EMsgGCCStrike15_v2_ClientRequestNewMission" => {
                Some(Self::KEMsgGccStrike15V2ClientRequestNewMission)
            }
            "k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo" => {
                Some(Self::KEMsgGccStrike15V2Gc2ClientTournamentInfo)
            }
            "k_EMsgGC_GlobalGame_Subscribe" => Some(Self::KEMsgGcGlobalGameSubscribe),
            "k_EMsgGC_GlobalGame_Unsubscribe" => Some(Self::KEMsgGcGlobalGameUnsubscribe),
            "k_EMsgGC_GlobalGame_Play" => Some(Self::KEMsgGcGlobalGamePlay),
            "k_EMsgGCCStrike15_v2_AcknowledgePenalty" => {
                Some(Self::KEMsgGccStrike15V2AcknowledgePenalty)
            }
            "k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin" => {
                Some(Self::KEMsgGccStrike15V2Client2GcRequestPrestigeCoin)
            }
            "k_EMsgGCCStrike15_v2_GC2ClientGlobalStats" => {
                Some(Self::KEMsgGccStrike15V2Gc2ClientGlobalStats)
            }
            "k_EMsgGCCStrike15_v2_Client2GCStreamUnlock" => {
                Some(Self::KEMsgGccStrike15V2Client2GcStreamUnlock)
            }
            "k_EMsgGCCStrike15_v2_FantasyRequestClientData" => {
                Some(Self::KEMsgGccStrike15V2FantasyRequestClientData)
            }
            "k_EMsgGCCStrike15_v2_FantasyUpdateClientData" => {
                Some(Self::KEMsgGccStrike15V2FantasyUpdateClientData)
            }
            "k_EMsgGCCStrike15_v2_GCToClientSteamdatagramTicket" => {
                Some(Self::KEMsgGccStrike15V2GcToClientSteamdatagramTicket)
            }
            "k_EMsgGCCStrike15_v2_ClientToGCRequestTicket" => {
                Some(Self::KEMsgGccStrike15V2ClientToGcRequestTicket)
            }
            "k_EMsgGCCStrike15_v2_ClientToGCRequestElevate" => {
                Some(Self::KEMsgGccStrike15V2ClientToGcRequestElevate)
            }
            "k_EMsgGCCStrike15_v2_GlobalChat" => Some(Self::KEMsgGccStrike15V2GlobalChat),
            "k_EMsgGCCStrike15_v2_GlobalChat_Subscribe" => {
                Some(Self::KEMsgGccStrike15V2GlobalChatSubscribe)
            }
            "k_EMsgGCCStrike15_v2_GlobalChat_Unsubscribe" => {
                Some(Self::KEMsgGccStrike15V2GlobalChatUnsubscribe)
            }
            "k_EMsgGCCStrike15_v2_ClientAuthKeyCode" => {
                Some(Self::KEMsgGccStrike15V2ClientAuthKeyCode)
            }
            "k_EMsgGCCStrike15_v2_GotvSyncPacket" => {
                Some(Self::KEMsgGccStrike15V2GotvSyncPacket)
            }
            "k_EMsgGCCStrike15_v2_ClientPlayerDecalSign" => {
                Some(Self::KEMsgGccStrike15V2ClientPlayerDecalSign)
            }
            "k_EMsgGCCStrike15_v2_ClientLogonFatalError" => {
                Some(Self::KEMsgGccStrike15V2ClientLogonFatalError)
            }
            "k_EMsgGCCStrike15_v2_ClientPollState" => {
                Some(Self::KEMsgGccStrike15V2ClientPollState)
            }
            "k_EMsgGCCStrike15_v2_Party_Register" => {
                Some(Self::KEMsgGccStrike15V2PartyRegister)
            }
            "k_EMsgGCCStrike15_v2_Party_Unregister" => {
                Some(Self::KEMsgGccStrike15V2PartyUnregister)
            }
            "k_EMsgGCCStrike15_v2_Party_Search" => {
                Some(Self::KEMsgGccStrike15V2PartySearch)
            }
            "k_EMsgGCCStrike15_v2_Party_Invite" => {
                Some(Self::KEMsgGccStrike15V2PartyInvite)
            }
            "k_EMsgGCCStrike15_v2_Account_RequestCoPlays" => {
                Some(Self::KEMsgGccStrike15V2AccountRequestCoPlays)
            }
            "k_EMsgGCCStrike15_v2_ClientGCRankUpdate" => {
                Some(Self::KEMsgGccStrike15V2ClientGcRankUpdate)
            }
            "k_EMsgGCCStrike15_v2_ClientRequestOffers" => {
                Some(Self::KEMsgGccStrike15V2ClientRequestOffers)
            }
            "k_EMsgGCCStrike15_v2_ClientAccountBalance" => {
                Some(Self::KEMsgGccStrike15V2ClientAccountBalance)
            }
            "k_EMsgGCCStrike15_v2_ClientPartyJoinRelay" => {
                Some(Self::KEMsgGccStrike15V2ClientPartyJoinRelay)
            }
            "k_EMsgGCCStrike15_v2_ClientPartyWarning" => {
                Some(Self::KEMsgGccStrike15V2ClientPartyWarning)
            }
            "k_EMsgGCCStrike15_v2_SetEventFavorite" => {
                Some(Self::KEMsgGccStrike15V2SetEventFavorite)
            }
            "k_EMsgGCCStrike15_v2_GetEventFavorites_Request" => {
                Some(Self::KEMsgGccStrike15V2GetEventFavoritesRequest)
            }
            "k_EMsgGCCStrike15_v2_ClientPerfReport" => {
                Some(Self::KEMsgGccStrike15V2ClientPerfReport)
            }
            "k_EMsgGCCStrike15_v2_GetEventFavorites_Response" => {
                Some(Self::KEMsgGccStrike15V2GetEventFavoritesResponse)
            }
            "k_EMsgGCCStrike15_v2_ClientRequestSouvenir" => {
                Some(Self::KEMsgGccStrike15V2ClientRequestSouvenir)
            }
            "k_EMsgGCCStrike15_v2_ClientReportValidation" => {
                Some(Self::KEMsgGccStrike15V2ClientReportValidation)
            }
            "k_EMsgGCCStrike15_v2_GC2ClientRefuseSecureMode" => {
                Some(Self::KEMsgGccStrike15V2Gc2ClientRefuseSecureMode)
            }
            "k_EMsgGCCStrike15_v2_GC2ClientRequestValidation" => {
                Some(Self::KEMsgGccStrike15V2Gc2ClientRequestValidation)
            }
            "k_EMsgGCCStrike15_v2_ClientRedeemMissionReward" => {
                Some(Self::KEMsgGccStrike15V2ClientRedeemMissionReward)
            }
            "k_EMsgGCCStrike15_ClientDeepStats" => {
                Some(Self::KEMsgGccStrike15ClientDeepStats)
            }
            "k_EMsgGCCStrike15_StartAgreementSessionInGame" => {
                Some(Self::KEMsgGccStrike15StartAgreementSessionInGame)
            }
            "k_EMsgGCCStrike15_v2_GC2ClientInitSystem" => {
                Some(Self::KEMsgGccStrike15V2Gc2ClientInitSystem)
            }
            "k_EMsgGCCStrike15_v2_GC2ClientInitSystem_Response" => {
                Some(Self::KEMsgGccStrike15V2Gc2ClientInitSystemResponse)
            }
            "k_EMsgGCCStrike15_v2_PrivateQueues" => {
                Some(Self::KEMsgGccStrike15V2PrivateQueues)
            }
            "k_EMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt" => {
                Some(Self::KEMsgGccStrike15V2MatchListTournamentOperatorMgmt)
            }
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ECsgoSteamUserStat {
    KECsgoSteamUserStatXpEarnedGames = 1,
    KECsgoSteamUserStatMatchWinsCompetitive = 2,
    KECsgoSteamUserStatSurvivedDangerZone = 3,
}
impl ECsgoSteamUserStat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ECsgoSteamUserStat::KECsgoSteamUserStatXpEarnedGames => {
                "k_ECsgoSteamUserStat_XpEarnedGames"
            }
            ECsgoSteamUserStat::KECsgoSteamUserStatMatchWinsCompetitive => {
                "k_ECsgoSteamUserStat_MatchWinsCompetitive"
            }
            ECsgoSteamUserStat::KECsgoSteamUserStatSurvivedDangerZone => {
                "k_ECsgoSteamUserStat_SurvivedDangerZone"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_ECsgoSteamUserStat_XpEarnedGames" => {
                Some(Self::KECsgoSteamUserStatXpEarnedGames)
            }
            "k_ECsgoSteamUserStat_MatchWinsCompetitive" => {
                Some(Self::KECsgoSteamUserStatMatchWinsCompetitive)
            }
            "k_ECsgoSteamUserStat_SurvivedDangerZone" => {
                Some(Self::KECsgoSteamUserStatSurvivedDangerZone)
            }
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EClientReportingVersion {
    KEClientReportingVersionOldVersion = 0,
    KEClientReportingVersionBetaVersion = 1,
    KEClientReportingVersionSupportsTrustedMode = 2,
}
impl EClientReportingVersion {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EClientReportingVersion::KEClientReportingVersionOldVersion => {
                "k_EClientReportingVersion_OldVersion"
            }
            EClientReportingVersion::KEClientReportingVersionBetaVersion => {
                "k_EClientReportingVersion_BetaVersion"
            }
            EClientReportingVersion::KEClientReportingVersionSupportsTrustedMode => {
                "k_EClientReportingVersion_SupportsTrustedMode"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_EClientReportingVersion_OldVersion" => {
                Some(Self::KEClientReportingVersionOldVersion)
            }
            "k_EClientReportingVersion_BetaVersion" => {
                Some(Self::KEClientReportingVersionBetaVersion)
            }
            "k_EClientReportingVersion_SupportsTrustedMode" => {
                Some(Self::KEClientReportingVersionSupportsTrustedMode)
            }
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EInitSystemResult {
    KEInitSystemResultInvalid = 0,
    KEInitSystemResultSuccess = 1,
    KEInitSystemResultNone = 2,
    KEInitSystemResultNotFound = 3,
    KEInitSystemResultExisting = 4,
    KEInitSystemResultFailedOpen = 5,
    KEInitSystemResultMismatch = 6,
    KEInitSystemResultFailedInit = 7,
    KEInitSystemResultMax = 8,
}
impl EInitSystemResult {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EInitSystemResult::KEInitSystemResultInvalid => "k_EInitSystemResult_Invalid",
            EInitSystemResult::KEInitSystemResultSuccess => "k_EInitSystemResult_Success",
            EInitSystemResult::KEInitSystemResultNone => "k_EInitSystemResult_None",
            EInitSystemResult::KEInitSystemResultNotFound => {
                "k_EInitSystemResult_NotFound"
            }
            EInitSystemResult::KEInitSystemResultExisting => {
                "k_EInitSystemResult_Existing"
            }
            EInitSystemResult::KEInitSystemResultFailedOpen => {
                "k_EInitSystemResult_FailedOpen"
            }
            EInitSystemResult::KEInitSystemResultMismatch => {
                "k_EInitSystemResult_Mismatch"
            }
            EInitSystemResult::KEInitSystemResultFailedInit => {
                "k_EInitSystemResult_FailedInit"
            }
            EInitSystemResult::KEInitSystemResultMax => "k_EInitSystemResult_Max",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_EInitSystemResult_Invalid" => Some(Self::KEInitSystemResultInvalid),
            "k_EInitSystemResult_Success" => Some(Self::KEInitSystemResultSuccess),
            "k_EInitSystemResult_None" => Some(Self::KEInitSystemResultNone),
            "k_EInitSystemResult_NotFound" => Some(Self::KEInitSystemResultNotFound),
            "k_EInitSystemResult_Existing" => Some(Self::KEInitSystemResultExisting),
            "k_EInitSystemResult_FailedOpen" => Some(Self::KEInitSystemResultFailedOpen),
            "k_EInitSystemResult_Mismatch" => Some(Self::KEInitSystemResultMismatch),
            "k_EInitSystemResult_FailedInit" => Some(Self::KEInitSystemResultFailedInit),
            "k_EInitSystemResult_Max" => Some(Self::KEInitSystemResultMax),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgVector {
    #[prost(float, optional, tag = "1")]
    pub x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub y: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub z: ::core::option::Option<f32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgVector2D {
    #[prost(float, optional, tag = "1")]
    pub x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub y: ::core::option::Option<f32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgQAngle {
    #[prost(float, optional, tag = "1")]
    pub x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub y: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub z: ::core::option::Option<f32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgRgba {
    #[prost(int32, optional, tag = "1")]
    pub r: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub g: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub b: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub a: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CnetMsgTick {
    #[prost(uint32, optional, tag = "1")]
    pub tick: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub host_computationtime: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub host_computationtime_std_deviation: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub host_framestarttime_std_deviation: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub hltv_replay_flags: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CnetMsgStringCmd {
    #[prost(string, optional, tag = "1")]
    pub command: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CnetMsgSignonState {
    #[prost(uint32, optional, tag = "1")]
    pub signon_state: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub spawn_count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub num_server_players: ::core::option::Option<u32>,
    #[prost(string, repeated, tag = "4")]
    pub players_networkids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub map_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgCVars {
    #[prost(message, repeated, tag = "1")]
    pub cvars: ::prost::alloc::vec::Vec<c_msg_c_vars::CVar>,
}
/// Nested message and enum types in `CMsg_CVars`.
pub mod c_msg_c_vars {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CVar {
        #[prost(string, optional, tag = "1")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "2")]
        pub value: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint32, optional, tag = "3")]
        pub dictionary_name: ::core::option::Option<u32>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CnetMsgSetConVar {
    #[prost(message, optional, tag = "1")]
    pub convars: ::core::option::Option<CMsgCVars>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CnetMsgNop {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CnetMsgDisconnect {
    #[prost(string, optional, tag = "1")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CnetMsgFile {
    #[prost(int32, optional, tag = "1")]
    pub transfer_id: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub file_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "3")]
    pub is_replay_demo_file: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "4")]
    pub deny: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CnetMsgSplitScreenUser {
    #[prost(int32, optional, tag = "1")]
    pub slot: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CnetMsgPlayerAvatarData {
    #[prost(uint32, optional, tag = "1")]
    pub accountid: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub rgb: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgClientInfo {
    #[prost(fixed32, optional, tag = "1")]
    pub send_table_crc: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub server_count: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "3")]
    pub is_hltv: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "4")]
    pub is_replay: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "5")]
    pub friends_id: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "6")]
    pub friends_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(fixed32, repeated, packed = "false", tag = "7")]
    pub custom_files: ::prost::alloc::vec::Vec<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgMove {
    #[prost(uint32, optional, tag = "1")]
    pub num_backup_commands: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub num_new_commands: ::core::option::Option<u32>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgVoiceData {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(fixed64, optional, tag = "2")]
    pub xuid: ::core::option::Option<u64>,
    #[prost(
        enumeration = "VoiceDataFormatT",
        optional,
        tag = "3",
        default = "VoicedataFormatEngine"
    )]
    pub format: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub sequence_bytes: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "5")]
    pub section_number: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub uncompressed_sample_offset: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgBaselineAck {
    #[prost(int32, optional, tag = "1")]
    pub baseline_tick: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub baseline_nr: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgListenEvents {
    #[prost(fixed32, repeated, packed = "false", tag = "1")]
    pub event_mask: ::prost::alloc::vec::Vec<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgRespondCvarValue {
    #[prost(int32, optional, tag = "1")]
    pub cookie: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub status_code: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgFileCrcCheck {
    #[prost(int32, optional, tag = "1")]
    pub code_path: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3")]
    pub code_filename: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "4")]
    pub filename: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "5")]
    pub file_fraction: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "6")]
    pub md5: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint32, optional, tag = "7")]
    pub crc: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "8")]
    pub file_hash_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "9")]
    pub file_len: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "10")]
    pub pack_file_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "11")]
    pub pack_file_number: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgLoadingProgress {
    #[prost(int32, optional, tag = "1")]
    pub progress: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgSplitPlayerConnect {
    #[prost(message, optional, tag = "1")]
    pub convars: ::core::option::Option<CMsgCVars>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgCmdKeyValues {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub keyvalues: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgServerInfo {
    #[prost(int32, optional, tag = "1")]
    pub protocol: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub server_count: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub is_dedicated: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "4")]
    pub is_official_valve_server: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "5")]
    pub is_hltv: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "6")]
    pub is_replay: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "21")]
    pub is_redirecting_to_proxy_relay: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "7")]
    pub c_os: ::core::option::Option<i32>,
    #[prost(fixed32, optional, tag = "8")]
    pub map_crc: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag = "9")]
    pub client_crc: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag = "10")]
    pub string_table_crc: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "11")]
    pub max_clients: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "12")]
    pub max_classes: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "13")]
    pub player_slot: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "14")]
    pub tick_interval: ::core::option::Option<f32>,
    #[prost(string, optional, tag = "15")]
    pub game_dir: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "16")]
    pub map_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "17")]
    pub map_group_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "18")]
    pub sky_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19")]
    pub host_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "20")]
    pub public_ip: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "22")]
    pub ugc_map_id: ::core::option::Option<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgClassInfo {
    #[prost(bool, optional, tag = "1")]
    pub create_on_client: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "2")]
    pub classes: ::prost::alloc::vec::Vec<csvc_msg_class_info::ClassT>,
}
/// Nested message and enum types in `CSVCMsg_ClassInfo`.
pub mod csvc_msg_class_info {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ClassT {
        #[prost(int32, optional, tag = "1")]
        pub class_id: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub data_table_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "3")]
        pub class_name: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgSendTable {
    #[prost(bool, optional, tag = "1")]
    pub is_end: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "2")]
    pub net_table_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "3")]
    pub needs_decoder: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "4")]
    pub props: ::prost::alloc::vec::Vec<csvc_msg_send_table::SendpropT>,
}
/// Nested message and enum types in `CSVCMsg_SendTable`.
pub mod csvc_msg_send_table {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SendpropT {
        #[prost(int32, optional, tag = "1")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub var_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int32, optional, tag = "3")]
        pub flags: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "4")]
        pub priority: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "5")]
        pub dt_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int32, optional, tag = "6")]
        pub num_elements: ::core::option::Option<i32>,
        #[prost(float, optional, tag = "7")]
        pub low_value: ::core::option::Option<f32>,
        #[prost(float, optional, tag = "8")]
        pub high_value: ::core::option::Option<f32>,
        #[prost(int32, optional, tag = "9")]
        pub num_bits: ::core::option::Option<i32>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgPrint {
    #[prost(string, optional, tag = "1")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgSetPause {
    #[prost(bool, optional, tag = "1")]
    pub paused: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgSetView {
    #[prost(int32, optional, tag = "1")]
    pub entity_index: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgCreateStringTable {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub max_entries: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub num_entries: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "4")]
    pub user_data_fixed_size: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "5")]
    pub user_data_size: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub user_data_size_bits: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub flags: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "8")]
    pub string_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgUpdateStringTable {
    #[prost(int32, optional, tag = "1")]
    pub table_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub num_changed_entries: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub string_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgVoiceInit {
    #[prost(int32, optional, tag = "1")]
    pub quality: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub codec: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3", default = "0")]
    pub version: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgVoiceData {
    #[prost(int32, optional, tag = "1")]
    pub client: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "2")]
    pub proximity: ::core::option::Option<bool>,
    #[prost(fixed64, optional, tag = "3")]
    pub xuid: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "4")]
    pub audible_mask: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "5")]
    pub voice_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "6")]
    pub caster: ::core::option::Option<bool>,
    #[prost(
        enumeration = "VoiceDataFormatT",
        optional,
        tag = "7",
        default = "VoicedataFormatEngine"
    )]
    pub format: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "8")]
    pub sequence_bytes: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "9")]
    pub section_number: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub uncompressed_sample_offset: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgFixAngle {
    #[prost(bool, optional, tag = "1")]
    pub relative: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "2")]
    pub angle: ::core::option::Option<CMsgQAngle>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgCrosshairAngle {
    #[prost(message, optional, tag = "1")]
    pub angle: ::core::option::Option<CMsgQAngle>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgPrefetch {
    #[prost(int32, optional, tag = "1")]
    pub sound_index: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgBspDecal {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<CMsgVector>,
    #[prost(int32, optional, tag = "2")]
    pub decal_texture_index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub entity_index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub model_index: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "5")]
    pub low_priority: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgSplitScreen {
    #[prost(
        enumeration = "ESplitScreenMessageType",
        optional,
        tag = "1",
        default = "MsgSplitscreenAdduser"
    )]
    pub r#type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub slot: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub player_index: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgGetCvarValue {
    #[prost(int32, optional, tag = "1")]
    pub cookie: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub cvar_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgMenu {
    #[prost(int32, optional, tag = "1")]
    pub dialog_type: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub menu_key_values: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgUserMessage {
    #[prost(int32, optional, tag = "1")]
    pub msg_type: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub msg_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int32, optional, tag = "3")]
    pub passthrough: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgPaintmapData {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub paintmap: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgGameEvent {
    #[prost(string, optional, tag = "1")]
    pub event_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub eventid: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "3")]
    pub keys: ::prost::alloc::vec::Vec<csvc_msg_game_event::KeyT>,
    #[prost(int32, optional, tag = "4")]
    pub passthrough: ::core::option::Option<i32>,
}
/// Nested message and enum types in `CSVCMsg_GameEvent`.
pub mod csvc_msg_game_event {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KeyT {
        #[prost(int32, optional, tag = "1")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub val_string: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(float, optional, tag = "3")]
        pub val_float: ::core::option::Option<f32>,
        #[prost(int32, optional, tag = "4")]
        pub val_long: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "5")]
        pub val_short: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "6")]
        pub val_byte: ::core::option::Option<i32>,
        #[prost(bool, optional, tag = "7")]
        pub val_bool: ::core::option::Option<bool>,
        #[prost(uint64, optional, tag = "8")]
        pub val_uint64: ::core::option::Option<u64>,
        #[prost(bytes = "vec", optional, tag = "9")]
        pub val_wstring: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgGameEventList {
    #[prost(message, repeated, tag = "1")]
    pub descriptors: ::prost::alloc::vec::Vec<csvc_msg_game_event_list::DescriptorT>,
}
/// Nested message and enum types in `CSVCMsg_GameEventList`.
pub mod csvc_msg_game_event_list {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KeyT {
        #[prost(int32, optional, tag = "1")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DescriptorT {
        #[prost(int32, optional, tag = "1")]
        pub eventid: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, repeated, tag = "3")]
        pub keys: ::prost::alloc::vec::Vec<KeyT>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgTempEntities {
    #[prost(bool, optional, tag = "1")]
    pub reliable: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "2")]
    pub num_entries: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub entity_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgPacketEntities {
    #[prost(int32, optional, tag = "1")]
    pub max_entries: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub updated_entries: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub is_delta: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "4")]
    pub update_baseline: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "5")]
    pub baseline: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub delta_from: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "7")]
    pub entity_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgSounds {
    #[prost(bool, optional, tag = "1")]
    pub reliable_sound: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "2")]
    pub sounds: ::prost::alloc::vec::Vec<csvc_msg_sounds::SounddataT>,
}
/// Nested message and enum types in `CSVCMsg_Sounds`.
pub mod csvc_msg_sounds {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SounddataT {
        #[prost(sint32, optional, tag = "1")]
        pub origin_x: ::core::option::Option<i32>,
        #[prost(sint32, optional, tag = "2")]
        pub origin_y: ::core::option::Option<i32>,
        #[prost(sint32, optional, tag = "3")]
        pub origin_z: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag = "4")]
        pub volume: ::core::option::Option<u32>,
        #[prost(float, optional, tag = "5")]
        pub delay_value: ::core::option::Option<f32>,
        #[prost(int32, optional, tag = "6")]
        pub sequence_number: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "7")]
        pub entity_index: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "8")]
        pub channel: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "9")]
        pub pitch: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "10")]
        pub flags: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag = "11")]
        pub sound_num: ::core::option::Option<u32>,
        #[prost(fixed32, optional, tag = "12")]
        pub sound_num_handle: ::core::option::Option<u32>,
        #[prost(int32, optional, tag = "13")]
        pub speaker_entity: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "14")]
        pub random_seed: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "15")]
        pub sound_level: ::core::option::Option<i32>,
        #[prost(bool, optional, tag = "16")]
        pub is_sentence: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "17")]
        pub is_ambient: ::core::option::Option<bool>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgEntityMsg {
    #[prost(int32, optional, tag = "1")]
    pub ent_index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub class_id: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub ent_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgCmdKeyValues {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub keyvalues: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgEncryptedData {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub encrypted: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int32, optional, tag = "2")]
    pub key_type: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgHltvReplay {
    #[prost(int32, optional, tag = "1")]
    pub delay: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub primary_target: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub replay_stop_at: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub replay_start_at: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub replay_slowdown_begin: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub replay_slowdown_end: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "7")]
    pub replay_slowdown_rate: ::core::option::Option<f32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgHltvReplay {
    #[prost(int32, optional, tag = "1")]
    pub request: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "2")]
    pub slowdown_length: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub slowdown_rate: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "4")]
    pub primary_target_ent_index: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "5")]
    pub event_time: ::core::option::Option<f32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgBroadcastCommand {
    #[prost(string, optional, tag = "1")]
    pub cmd: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NetMessages {
    NetNop = 0,
    NetDisconnect = 1,
    NetFile = 2,
    NetSplitScreenUser = 3,
    NetTick = 4,
    NetStringCmd = 5,
    NetSetConVar = 6,
    NetSignonState = 7,
    NetPlayerAvatarData = 100,
}
impl NetMessages {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            NetMessages::NetNop => "net_NOP",
            NetMessages::NetDisconnect => "net_Disconnect",
            NetMessages::NetFile => "net_File",
            NetMessages::NetSplitScreenUser => "net_SplitScreenUser",
            NetMessages::NetTick => "net_Tick",
            NetMessages::NetStringCmd => "net_StringCmd",
            NetMessages::NetSetConVar => "net_SetConVar",
            NetMessages::NetSignonState => "net_SignonState",
            NetMessages::NetPlayerAvatarData => "net_PlayerAvatarData",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "net_NOP" => Some(Self::NetNop),
            "net_Disconnect" => Some(Self::NetDisconnect),
            "net_File" => Some(Self::NetFile),
            "net_SplitScreenUser" => Some(Self::NetSplitScreenUser),
            "net_Tick" => Some(Self::NetTick),
            "net_StringCmd" => Some(Self::NetStringCmd),
            "net_SetConVar" => Some(Self::NetSetConVar),
            "net_SignonState" => Some(Self::NetSignonState),
            "net_PlayerAvatarData" => Some(Self::NetPlayerAvatarData),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ClcMessages {
    ClcClientInfo = 8,
    ClcMove = 9,
    ClcVoiceData = 10,
    ClcBaselineAck = 11,
    ClcListenEvents = 12,
    ClcRespondCvarValue = 13,
    ClcFileCrcCheck = 14,
    ClcLoadingProgress = 15,
    ClcSplitPlayerConnect = 16,
    ClcClientMessage = 17,
    ClcCmdKeyValues = 18,
    ClcHltvReplay = 20,
}
impl ClcMessages {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ClcMessages::ClcClientInfo => "clc_ClientInfo",
            ClcMessages::ClcMove => "clc_Move",
            ClcMessages::ClcVoiceData => "clc_VoiceData",
            ClcMessages::ClcBaselineAck => "clc_BaselineAck",
            ClcMessages::ClcListenEvents => "clc_ListenEvents",
            ClcMessages::ClcRespondCvarValue => "clc_RespondCvarValue",
            ClcMessages::ClcFileCrcCheck => "clc_FileCRCCheck",
            ClcMessages::ClcLoadingProgress => "clc_LoadingProgress",
            ClcMessages::ClcSplitPlayerConnect => "clc_SplitPlayerConnect",
            ClcMessages::ClcClientMessage => "clc_ClientMessage",
            ClcMessages::ClcCmdKeyValues => "clc_CmdKeyValues",
            ClcMessages::ClcHltvReplay => "clc_HltvReplay",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "clc_ClientInfo" => Some(Self::ClcClientInfo),
            "clc_Move" => Some(Self::ClcMove),
            "clc_VoiceData" => Some(Self::ClcVoiceData),
            "clc_BaselineAck" => Some(Self::ClcBaselineAck),
            "clc_ListenEvents" => Some(Self::ClcListenEvents),
            "clc_RespondCvarValue" => Some(Self::ClcRespondCvarValue),
            "clc_FileCRCCheck" => Some(Self::ClcFileCrcCheck),
            "clc_LoadingProgress" => Some(Self::ClcLoadingProgress),
            "clc_SplitPlayerConnect" => Some(Self::ClcSplitPlayerConnect),
            "clc_ClientMessage" => Some(Self::ClcClientMessage),
            "clc_CmdKeyValues" => Some(Self::ClcCmdKeyValues),
            "clc_HltvReplay" => Some(Self::ClcHltvReplay),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VoiceDataFormatT {
    VoicedataFormatSteam = 0,
    VoicedataFormatEngine = 1,
}
impl VoiceDataFormatT {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            VoiceDataFormatT::VoicedataFormatSteam => "VOICEDATA_FORMAT_STEAM",
            VoiceDataFormatT::VoicedataFormatEngine => "VOICEDATA_FORMAT_ENGINE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VOICEDATA_FORMAT_STEAM" => Some(Self::VoicedataFormatSteam),
            "VOICEDATA_FORMAT_ENGINE" => Some(Self::VoicedataFormatEngine),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ESplitScreenMessageType {
    MsgSplitscreenAdduser = 0,
    MsgSplitscreenRemoveuser = 1,
}
impl ESplitScreenMessageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ESplitScreenMessageType::MsgSplitscreenAdduser => "MSG_SPLITSCREEN_ADDUSER",
            ESplitScreenMessageType::MsgSplitscreenRemoveuser => {
                "MSG_SPLITSCREEN_REMOVEUSER"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MSG_SPLITSCREEN_ADDUSER" => Some(Self::MsgSplitscreenAdduser),
            "MSG_SPLITSCREEN_REMOVEUSER" => Some(Self::MsgSplitscreenRemoveuser),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SvcMessages {
    SvcServerInfo = 8,
    SvcSendTable = 9,
    SvcClassInfo = 10,
    SvcSetPause = 11,
    SvcCreateStringTable = 12,
    SvcUpdateStringTable = 13,
    SvcVoiceInit = 14,
    SvcVoiceData = 15,
    SvcPrint = 16,
    SvcSounds = 17,
    SvcSetView = 18,
    SvcFixAngle = 19,
    SvcCrosshairAngle = 20,
    SvcBspDecal = 21,
    SvcSplitScreen = 22,
    SvcUserMessage = 23,
    SvcEntityMessage = 24,
    SvcGameEvent = 25,
    SvcPacketEntities = 26,
    SvcTempEntities = 27,
    SvcPrefetch = 28,
    SvcMenu = 29,
    SvcGameEventList = 30,
    SvcGetCvarValue = 31,
    SvcPaintmapData = 33,
    SvcCmdKeyValues = 34,
    SvcEncryptedData = 35,
    SvcHltvReplay = 36,
    SvcBroadcastCommand = 38,
}
impl SvcMessages {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SvcMessages::SvcServerInfo => "svc_ServerInfo",
            SvcMessages::SvcSendTable => "svc_SendTable",
            SvcMessages::SvcClassInfo => "svc_ClassInfo",
            SvcMessages::SvcSetPause => "svc_SetPause",
            SvcMessages::SvcCreateStringTable => "svc_CreateStringTable",
            SvcMessages::SvcUpdateStringTable => "svc_UpdateStringTable",
            SvcMessages::SvcVoiceInit => "svc_VoiceInit",
            SvcMessages::SvcVoiceData => "svc_VoiceData",
            SvcMessages::SvcPrint => "svc_Print",
            SvcMessages::SvcSounds => "svc_Sounds",
            SvcMessages::SvcSetView => "svc_SetView",
            SvcMessages::SvcFixAngle => "svc_FixAngle",
            SvcMessages::SvcCrosshairAngle => "svc_CrosshairAngle",
            SvcMessages::SvcBspDecal => "svc_BSPDecal",
            SvcMessages::SvcSplitScreen => "svc_SplitScreen",
            SvcMessages::SvcUserMessage => "svc_UserMessage",
            SvcMessages::SvcEntityMessage => "svc_EntityMessage",
            SvcMessages::SvcGameEvent => "svc_GameEvent",
            SvcMessages::SvcPacketEntities => "svc_PacketEntities",
            SvcMessages::SvcTempEntities => "svc_TempEntities",
            SvcMessages::SvcPrefetch => "svc_Prefetch",
            SvcMessages::SvcMenu => "svc_Menu",
            SvcMessages::SvcGameEventList => "svc_GameEventList",
            SvcMessages::SvcGetCvarValue => "svc_GetCvarValue",
            SvcMessages::SvcPaintmapData => "svc_PaintmapData",
            SvcMessages::SvcCmdKeyValues => "svc_CmdKeyValues",
            SvcMessages::SvcEncryptedData => "svc_EncryptedData",
            SvcMessages::SvcHltvReplay => "svc_HltvReplay",
            SvcMessages::SvcBroadcastCommand => "svc_Broadcast_Command",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "svc_ServerInfo" => Some(Self::SvcServerInfo),
            "svc_SendTable" => Some(Self::SvcSendTable),
            "svc_ClassInfo" => Some(Self::SvcClassInfo),
            "svc_SetPause" => Some(Self::SvcSetPause),
            "svc_CreateStringTable" => Some(Self::SvcCreateStringTable),
            "svc_UpdateStringTable" => Some(Self::SvcUpdateStringTable),
            "svc_VoiceInit" => Some(Self::SvcVoiceInit),
            "svc_VoiceData" => Some(Self::SvcVoiceData),
            "svc_Print" => Some(Self::SvcPrint),
            "svc_Sounds" => Some(Self::SvcSounds),
            "svc_SetView" => Some(Self::SvcSetView),
            "svc_FixAngle" => Some(Self::SvcFixAngle),
            "svc_CrosshairAngle" => Some(Self::SvcCrosshairAngle),
            "svc_BSPDecal" => Some(Self::SvcBspDecal),
            "svc_SplitScreen" => Some(Self::SvcSplitScreen),
            "svc_UserMessage" => Some(Self::SvcUserMessage),
            "svc_EntityMessage" => Some(Self::SvcEntityMessage),
            "svc_GameEvent" => Some(Self::SvcGameEvent),
            "svc_PacketEntities" => Some(Self::SvcPacketEntities),
            "svc_TempEntities" => Some(Self::SvcTempEntities),
            "svc_Prefetch" => Some(Self::SvcPrefetch),
            "svc_Menu" => Some(Self::SvcMenu),
            "svc_GameEventList" => Some(Self::SvcGameEventList),
            "svc_GetCvarValue" => Some(Self::SvcGetCvarValue),
            "svc_PaintmapData" => Some(Self::SvcPaintmapData),
            "svc_CmdKeyValues" => Some(Self::SvcCmdKeyValues),
            "svc_EncryptedData" => Some(Self::SvcEncryptedData),
            "svc_HltvReplay" => Some(Self::SvcHltvReplay),
            "svc_Broadcast_Command" => Some(Self::SvcBroadcastCommand),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReplayEventTypeT {
    ReplayEventCancel = 0,
    ReplayEventDeath = 1,
    ReplayEventGeneric = 2,
    ReplayEventStuckNeedFullUpdate = 3,
}
impl ReplayEventTypeT {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ReplayEventTypeT::ReplayEventCancel => "REPLAY_EVENT_CANCEL",
            ReplayEventTypeT::ReplayEventDeath => "REPLAY_EVENT_DEATH",
            ReplayEventTypeT::ReplayEventGeneric => "REPLAY_EVENT_GENERIC",
            ReplayEventTypeT::ReplayEventStuckNeedFullUpdate => {
                "REPLAY_EVENT_STUCK_NEED_FULL_UPDATE"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REPLAY_EVENT_CANCEL" => Some(Self::ReplayEventCancel),
            "REPLAY_EVENT_DEATH" => Some(Self::ReplayEventDeath),
            "REPLAY_EVENT_GENERIC" => Some(Self::ReplayEventGeneric),
            "REPLAY_EVENT_STUCK_NEED_FULL_UPDATE" => {
                Some(Self::ReplayEventStuckNeedFullUpdate)
            }
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgVguiMenu {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "2")]
    pub show: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "3")]
    pub subkeys: ::prost::alloc::vec::Vec<ccs_usr_msg_vgui_menu::Subkey>,
}
/// Nested message and enum types in `CCSUsrMsg_VGUIMenu`.
pub mod ccs_usr_msg_vgui_menu {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Subkey {
        #[prost(string, optional, tag = "1")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "2")]
        pub str: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgGeiger {
    #[prost(int32, optional, tag = "1")]
    pub range: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgTrain {
    #[prost(int32, optional, tag = "1")]
    pub train: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgHudText {
    #[prost(string, optional, tag = "1")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgSayText {
    #[prost(int32, optional, tag = "1")]
    pub ent_idx: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "3")]
    pub chat: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "4")]
    pub textallchat: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgSayText2 {
    #[prost(int32, optional, tag = "1")]
    pub ent_idx: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "2")]
    pub chat: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "3")]
    pub msg_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4")]
    pub params: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "5")]
    pub textallchat: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgTextMsg {
    #[prost(int32, optional, tag = "1")]
    pub msg_dst: ::core::option::Option<i32>,
    #[prost(string, repeated, tag = "3")]
    pub params: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgHudMsg {
    #[prost(int32, optional, tag = "1")]
    pub channel: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub pos: ::core::option::Option<CMsgVector2D>,
    #[prost(message, optional, tag = "3")]
    pub clr1: ::core::option::Option<CMsgRgba>,
    #[prost(message, optional, tag = "4")]
    pub clr2: ::core::option::Option<CMsgRgba>,
    #[prost(int32, optional, tag = "5")]
    pub effect: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "6")]
    pub fade_in_time: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "7")]
    pub fade_out_time: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "9")]
    pub hold_time: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "10")]
    pub fx_time: ::core::option::Option<f32>,
    #[prost(string, optional, tag = "11")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgShake {
    #[prost(int32, optional, tag = "1")]
    pub command: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "2")]
    pub local_amplitude: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub frequency: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub duration: ::core::option::Option<f32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgFade {
    #[prost(int32, optional, tag = "1")]
    pub duration: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub hold_time: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub flags: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "4")]
    pub clr: ::core::option::Option<CMsgRgba>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgRumble {
    #[prost(int32, optional, tag = "1")]
    pub index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub data: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub flags: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgCloseCaption {
    #[prost(uint32, optional, tag = "1")]
    pub hash: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub duration: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub from_player: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "4")]
    pub cctoken: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgCloseCaptionDirect {
    #[prost(uint32, optional, tag = "1")]
    pub hash: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub duration: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub from_player: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgSendAudio {
    #[prost(string, optional, tag = "1")]
    pub radio_sound: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgRawAudio {
    #[prost(int32, optional, tag = "1")]
    pub pitch: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub entidx: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "3")]
    pub duration: ::core::option::Option<f32>,
    #[prost(string, optional, tag = "4")]
    pub voice_filename: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgVoiceMask {
    #[prost(message, repeated, tag = "1")]
    pub player_masks: ::prost::alloc::vec::Vec<ccs_usr_msg_voice_mask::PlayerMask>,
    #[prost(bool, optional, tag = "2")]
    pub player_mod_enable: ::core::option::Option<bool>,
}
/// Nested message and enum types in `CCSUsrMsg_VoiceMask`.
pub mod ccs_usr_msg_voice_mask {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PlayerMask {
        #[prost(int32, optional, tag = "1")]
        pub game_rules_mask: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub ban_masks: ::core::option::Option<i32>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgDamage {
    #[prost(int32, optional, tag = "1")]
    pub amount: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub inflictor_world_pos: ::core::option::Option<CMsgVector>,
    #[prost(int32, optional, tag = "3")]
    pub victim_entindex: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgRadioText {
    #[prost(int32, optional, tag = "1")]
    pub msg_dst: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub client: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    pub msg_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4")]
    pub params: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgHintText {
    #[prost(string, optional, tag = "1")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgKeyHintText {
    #[prost(string, repeated, tag = "1")]
    pub hints: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgProcessSpottedEntityUpdate {
    #[prost(bool, optional, tag = "1")]
    pub new_update: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "2")]
    pub entity_updates: ::prost::alloc::vec::Vec<
        ccs_usr_msg_process_spotted_entity_update::SpottedEntityUpdate,
    >,
}
/// Nested message and enum types in `CCSUsrMsg_ProcessSpottedEntityUpdate`.
pub mod ccs_usr_msg_process_spotted_entity_update {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SpottedEntityUpdate {
        #[prost(int32, optional, tag = "1")]
        pub entity_idx: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub class_id: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "3")]
        pub origin_x: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "4")]
        pub origin_y: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "5")]
        pub origin_z: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "6")]
        pub angle_y: ::core::option::Option<i32>,
        #[prost(bool, optional, tag = "7")]
        pub defuser: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "8")]
        pub player_has_defuser: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "9")]
        pub player_has_c4: ::core::option::Option<bool>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgSendPlayerItemDrops {
    #[prost(message, repeated, tag = "1")]
    pub entity_updates: ::prost::alloc::vec::Vec<CEconItemPreviewDataBlock>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgSendPlayerItemFound {
    #[prost(message, optional, tag = "1")]
    pub iteminfo: ::core::option::Option<CEconItemPreviewDataBlock>,
    #[prost(int32, optional, tag = "2")]
    pub entindex: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgReloadEffect {
    #[prost(int32, optional, tag = "1")]
    pub entidx: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub actanim: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "3")]
    pub origin_x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub origin_y: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "5")]
    pub origin_z: ::core::option::Option<f32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgWeaponSound {
    #[prost(int32, optional, tag = "1")]
    pub entidx: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "2")]
    pub origin_x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub origin_y: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub origin_z: ::core::option::Option<f32>,
    #[prost(string, optional, tag = "5")]
    pub sound: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(float, optional, tag = "6")]
    pub timestamp: ::core::option::Option<f32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgUpdateScreenHealthBar {
    #[prost(int32, optional, tag = "1")]
    pub entidx: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "2")]
    pub healthratio_old: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub healthratio_new: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "4")]
    pub style: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgEntityOutlineHighlight {
    #[prost(int32, optional, tag = "1")]
    pub entidx: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "2")]
    pub removehighlight: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgAdjustMoney {
    #[prost(int32, optional, tag = "1")]
    pub amount: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgReportHit {
    #[prost(float, optional, tag = "1")]
    pub pos_x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub pos_y: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub timestamp: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub pos_z: ::core::option::Option<f32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgKillCam {
    #[prost(int32, optional, tag = "1")]
    pub obs_mode: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub first_target: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub second_target: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgDesiredTimescale {
    #[prost(float, optional, tag = "1")]
    pub desired_timescale: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub duration_realtime_sec: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "3")]
    pub interpolator_type: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "4")]
    pub start_blend_time: ::core::option::Option<f32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgCurrentTimescale {
    #[prost(float, optional, tag = "1")]
    pub cur_timescale: ::core::option::Option<f32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgAchievementEvent {
    #[prost(int32, optional, tag = "1")]
    pub achievement: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub count: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub user_id: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgMatchEndConditions {
    #[prost(int32, optional, tag = "1")]
    pub fraglimit: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub mp_maxrounds: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub mp_winlimit: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub mp_timelimit: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgPlayerStatsUpdate {
    #[prost(int32, optional, tag = "1")]
    pub version: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "4")]
    pub stats: ::prost::alloc::vec::Vec<ccs_usr_msg_player_stats_update::Stat>,
    #[prost(int32, optional, tag = "5")]
    pub user_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub crc: ::core::option::Option<i32>,
}
/// Nested message and enum types in `CCSUsrMsg_PlayerStatsUpdate`.
pub mod ccs_usr_msg_player_stats_update {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Stat {
        #[prost(int32, optional, tag = "1")]
        pub idx: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub delta: ::core::option::Option<i32>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgDisplayInventory {
    #[prost(bool, optional, tag = "1")]
    pub display: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "2")]
    pub user_id: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgQuestProgress {
    #[prost(uint32, optional, tag = "1")]
    pub quest_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub normal_points: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub bonus_points: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "4")]
    pub is_event_quest: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgScoreLeaderboardData {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ScoreLeaderboardData>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgPlayerDecalDigitalSignature {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<PlayerDecalDigitalSignature>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgXRankGet {
    #[prost(int32, optional, tag = "1")]
    pub mode_idx: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub controller: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgXRankUpd {
    #[prost(int32, optional, tag = "1")]
    pub mode_idx: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub controller: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub ranking: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgCallVoteFailed {
    #[prost(int32, optional, tag = "1")]
    pub reason: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub time: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgVoteStart {
    #[prost(int32, optional, tag = "1")]
    pub team: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub ent_idx: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub vote_type: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "4")]
    pub disp_str: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub details_str: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub other_team_str: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "7")]
    pub is_yes_no_vote: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "8")]
    pub entidx_target: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgVotePass {
    #[prost(int32, optional, tag = "1")]
    pub team: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub vote_type: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    pub disp_str: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub details_str: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgVoteFailed {
    #[prost(int32, optional, tag = "1")]
    pub team: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub reason: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgVoteSetup {
    #[prost(string, repeated, tag = "1")]
    pub potential_issues: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgSendLastKillerDamageToClient {
    #[prost(int32, optional, tag = "1")]
    pub num_hits_given: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub damage_given: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub num_hits_taken: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub damage_taken: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgServerRankUpdate {
    #[prost(message, repeated, tag = "1")]
    pub rank_update: ::prost::alloc::vec::Vec<
        ccs_usr_msg_server_rank_update::RankUpdate,
    >,
}
/// Nested message and enum types in `CCSUsrMsg_ServerRankUpdate`.
pub mod ccs_usr_msg_server_rank_update {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RankUpdate {
        #[prost(int32, optional, tag = "1")]
        pub account_id: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub rank_old: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "3")]
        pub rank_new: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "4")]
        pub num_wins: ::core::option::Option<i32>,
        #[prost(float, optional, tag = "5")]
        pub rank_change: ::core::option::Option<f32>,
        #[prost(int32, optional, tag = "6")]
        pub rank_type_id: ::core::option::Option<i32>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgXpUpdate {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<CMsgGcCstrike15V2Gc2ServerNotifyXpRewarded>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgItemPickup {
    #[prost(string, optional, tag = "1")]
    pub item: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgShowMenu {
    #[prost(int32, optional, tag = "1")]
    pub bits_valid_slots: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub display_time: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    pub menu_string: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgBarTime {
    #[prost(string, optional, tag = "1")]
    pub time: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgAmmoDenied {
    #[prost(int32, optional, tag = "1")]
    pub ammo_idx: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgMarkAchievement {
    #[prost(string, optional, tag = "1")]
    pub achievement: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgMatchStatsUpdate {
    #[prost(string, optional, tag = "1")]
    pub update: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgItemDrop {
    #[prost(int64, optional, tag = "1")]
    pub itemid: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "2")]
    pub death: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgGlowPropTurnOff {
    #[prost(int32, optional, tag = "1")]
    pub entidx: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgRoundBackupFilenames {
    #[prost(int32, optional, tag = "1")]
    pub count: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub index: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    pub filename: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub nicename: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgSsui {
    #[prost(bool, optional, tag = "1")]
    pub show: ::core::option::Option<bool>,
    #[prost(float, optional, tag = "2")]
    pub start_time: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub end_time: ::core::option::Option<f32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgSurvivalStats {
    #[prost(uint64, optional, tag = "1")]
    pub xuid: ::core::option::Option<u64>,
    #[prost(message, repeated, tag = "2")]
    pub facts: ::prost::alloc::vec::Vec<ccs_usr_msg_survival_stats::Fact>,
    #[prost(message, repeated, tag = "3")]
    pub users: ::prost::alloc::vec::Vec<ccs_usr_msg_survival_stats::Placement>,
    #[prost(message, repeated, tag = "5")]
    pub damages: ::prost::alloc::vec::Vec<ccs_usr_msg_survival_stats::Damage>,
    #[prost(int32, optional, tag = "4")]
    pub ticknumber: ::core::option::Option<i32>,
}
/// Nested message and enum types in `CCSUsrMsg_SurvivalStats`.
pub mod ccs_usr_msg_survival_stats {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Fact {
        #[prost(int32, optional, tag = "1")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub display: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "3")]
        pub value: ::core::option::Option<i32>,
        #[prost(float, optional, tag = "4")]
        pub interestingness: ::core::option::Option<f32>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Placement {
        #[prost(uint64, optional, tag = "1")]
        pub xuid: ::core::option::Option<u64>,
        #[prost(int32, optional, tag = "2")]
        pub teamnumber: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "3")]
        pub placement: ::core::option::Option<i32>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Damage {
        #[prost(uint64, optional, tag = "1")]
        pub xuid: ::core::option::Option<u64>,
        #[prost(int32, optional, tag = "2")]
        pub to: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "3")]
        pub to_hits: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "4")]
        pub from: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "5")]
        pub from_hits: ::core::option::Option<i32>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgEndOfMatchAllPlayersData {
    #[prost(message, repeated, tag = "1")]
    pub allplayerdata: ::prost::alloc::vec::Vec<
        ccs_usr_msg_end_of_match_all_players_data::PlayerData,
    >,
    #[prost(int32, optional, tag = "2")]
    pub scene: ::core::option::Option<i32>,
}
/// Nested message and enum types in `CCSUsrMsg_EndOfMatchAllPlayersData`.
pub mod ccs_usr_msg_end_of_match_all_players_data {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Accolade {
        #[prost(int32, optional, tag = "1")]
        pub eaccolade: ::core::option::Option<i32>,
        #[prost(float, optional, tag = "2")]
        pub value: ::core::option::Option<f32>,
        #[prost(int32, optional, tag = "3")]
        pub position: ::core::option::Option<i32>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PlayerData {
        #[prost(int32, optional, tag = "1")]
        pub entindex: ::core::option::Option<i32>,
        #[prost(uint64, optional, tag = "2")]
        pub xuid: ::core::option::Option<u64>,
        #[prost(string, optional, tag = "3")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int32, optional, tag = "4")]
        pub teamnumber: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "5")]
        pub nomination: ::core::option::Option<Accolade>,
        #[prost(message, repeated, tag = "6")]
        pub items: ::prost::alloc::vec::Vec<super::CEconItemPreviewDataBlock>,
        #[prost(int32, optional, tag = "7")]
        pub playercolor: ::core::option::Option<i32>,
        #[prost(bool, optional, tag = "8")]
        pub isbot: ::core::option::Option<bool>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgRoundImpactScoreData {
    #[prost(message, optional, tag = "1")]
    pub init_conditions: ::core::option::Option<
        ccs_usr_msg_round_impact_score_data::InitialConditions,
    >,
    #[prost(message, repeated, tag = "2")]
    pub all_ris_event_data: ::prost::alloc::vec::Vec<
        ccs_usr_msg_round_impact_score_data::RisEvent,
    >,
}
/// Nested message and enum types in `CCSUsrMsg_RoundImpactScoreData`.
pub mod ccs_usr_msg_round_impact_score_data {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RisEvent {
        #[prost(float, optional, tag = "1")]
        pub timestamp: ::core::option::Option<f32>,
        #[prost(int32, optional, tag = "2")]
        pub terrorist_odds: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "3")]
        pub ct_alive: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "4")]
        pub t_alive: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "5")]
        pub victim_data: ::core::option::Option<ris_event::Victim>,
        #[prost(message, optional, tag = "6")]
        pub objective_data: ::core::option::Option<ris_event::Objective>,
        #[prost(message, repeated, tag = "7")]
        pub all_damage_data: ::prost::alloc::vec::Vec<ris_event::Damage>,
    }
    /// Nested message and enum types in `RisEvent`.
    pub mod ris_event {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Victim {
            #[prost(int32, optional, tag = "1")]
            pub team_number: ::core::option::Option<i32>,
            #[prost(int32, optional, tag = "2")]
            pub entindex: ::core::option::Option<i32>,
            #[prost(uint64, optional, tag = "3")]
            pub xuid: ::core::option::Option<u64>,
            #[prost(int32, optional, tag = "4")]
            pub color: ::core::option::Option<i32>,
            #[prost(bool, optional, tag = "5")]
            pub is_bot: ::core::option::Option<bool>,
            #[prost(bool, optional, tag = "6")]
            pub is_dead: ::core::option::Option<bool>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Objective {
            #[prost(int32, optional, tag = "1")]
            pub r#type: ::core::option::Option<i32>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Damage {
            #[prost(int32, optional, tag = "1")]
            pub target_entindex: ::core::option::Option<i32>,
            #[prost(uint64, optional, tag = "2")]
            pub target_xuid: ::core::option::Option<u64>,
            #[prost(int32, optional, tag = "3")]
            pub health_removed: ::core::option::Option<i32>,
            #[prost(int32, optional, tag = "4")]
            pub num_hits: ::core::option::Option<i32>,
            #[prost(int32, optional, tag = "5")]
            pub return_health_removed: ::core::option::Option<i32>,
            #[prost(int32, optional, tag = "6")]
            pub num_return_hits: ::core::option::Option<i32>,
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InitialConditions {
        #[prost(int32, optional, tag = "1")]
        pub ct_equip_value: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub t_equip_value: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "3")]
        pub terrorist_odds: ::core::option::Option<i32>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgCurrentRoundOdds {
    #[prost(int32, optional, tag = "1")]
    pub odds: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgDeepStats {
    #[prost(message, optional, tag = "1")]
    pub stats: ::core::option::Option<CMsgGccStrike15ClientDeepStats>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgResetHud {
    #[prost(bool, optional, tag = "1")]
    pub reset: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgGameTitle {
    #[prost(int32, optional, tag = "1")]
    pub dummy: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgRequestState {
    #[prost(int32, optional, tag = "1")]
    pub dummy: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgStopSpectatorMode {
    #[prost(int32, optional, tag = "1")]
    pub dummy: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgDisconnectToLobby {
    #[prost(int32, optional, tag = "1")]
    pub dummy: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgWarmupHasEnded {
    #[prost(int32, optional, tag = "1")]
    pub dummy: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgClientInfo {
    #[prost(int32, optional, tag = "1")]
    pub dummy: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgServerRankRevealAll {
    #[prost(int32, optional, tag = "1")]
    pub seconds_till_shutdown: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub reservation: ::core::option::Option<
        CMsgGccStrike15V2MatchmakingGc2ServerReserve,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgUtilMsg {
    #[prost(string, optional, tag = "1")]
    pub util_action: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub util1: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub util2: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub util3: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub util4: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub util5: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgUtilMsgResponse {
    #[prost(fixed32, optional, tag = "1")]
    pub crc: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub item_count: ::core::option::Option<i32>,
    #[prost(fixed32, optional, tag = "3")]
    pub crc2: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4")]
    pub item_count2: ::core::option::Option<i32>,
    #[prost(int32, repeated, packed = "false", tag = "5")]
    pub crc_part: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed = "false", tag = "6")]
    pub crc_part2: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, optional, tag = "7")]
    pub client_timestamp: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "8")]
    pub platform: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "9")]
    pub itemdetails: ::prost::alloc::vec::Vec<ccs_usr_msg_util_msg_response::ItemDetail>,
    #[prost(int32, optional, tag = "10")]
    pub itemgroup: ::core::option::Option<i32>,
}
/// Nested message and enum types in `CCSUsrMsg_UtilMsg_Response`.
pub mod ccs_usr_msg_util_msg_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ItemDetail {
        #[prost(int32, optional, tag = "1")]
        pub index: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub hash: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "3")]
        pub crc: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "4")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ECstrike15UserMessages {
    CsUmVguiMenu = 1,
    CsUmGeiger = 2,
    CsUmTrain = 3,
    CsUmHudText = 4,
    CsUmSayText = 5,
    CsUmSayText2 = 6,
    CsUmTextMsg = 7,
    CsUmHudMsg = 8,
    CsUmResetHud = 9,
    CsUmGameTitle = 10,
    CsUmShake = 12,
    CsUmFade = 13,
    CsUmRumble = 14,
    CsUmCloseCaption = 15,
    CsUmCloseCaptionDirect = 16,
    CsUmSendAudio = 17,
    CsUmRawAudio = 18,
    CsUmVoiceMask = 19,
    CsUmRequestState = 20,
    CsUmDamage = 21,
    CsUmRadioText = 22,
    CsUmHintText = 23,
    CsUmKeyHintText = 24,
    CsUmProcessSpottedEntityUpdate = 25,
    CsUmReloadEffect = 26,
    CsUmAdjustMoney = 27,
    CsUmUpdateTeamMoney = 28,
    CsUmStopSpectatorMode = 29,
    CsUmKillCam = 30,
    CsUmDesiredTimescale = 31,
    CsUmCurrentTimescale = 32,
    CsUmAchievementEvent = 33,
    CsUmMatchEndConditions = 34,
    CsUmDisconnectToLobby = 35,
    CsUmPlayerStatsUpdate = 36,
    CsUmDisplayInventory = 37,
    CsUmWarmupHasEnded = 38,
    CsUmClientInfo = 39,
    CsUmXRankGet = 40,
    CsUmXRankUpd = 41,
    CsUmCallVoteFailed = 45,
    CsUmVoteStart = 46,
    CsUmVotePass = 47,
    CsUmVoteFailed = 48,
    CsUmVoteSetup = 49,
    CsUmServerRankRevealAll = 50,
    CsUmSendLastKillerDamageToClient = 51,
    CsUmServerRankUpdate = 52,
    CsUmItemPickup = 53,
    CsUmShowMenu = 54,
    CsUmBarTime = 55,
    CsUmAmmoDenied = 56,
    CsUmMarkAchievement = 57,
    CsUmMatchStatsUpdate = 58,
    CsUmItemDrop = 59,
    CsUmGlowPropTurnOff = 60,
    CsUmSendPlayerItemDrops = 61,
    CsUmRoundBackupFilenames = 62,
    CsUmSendPlayerItemFound = 63,
    CsUmReportHit = 64,
    CsUmXpUpdate = 65,
    CsUmQuestProgress = 66,
    CsUmScoreLeaderboardData = 67,
    CsUmPlayerDecalDigitalSignature = 68,
    CsUmWeaponSound = 69,
    CsUmUpdateScreenHealthBar = 70,
    CsUmEntityOutlineHighlight = 71,
    CsUmSsui = 72,
    CsUmSurvivalStats = 73,
    CsUmDisconnectToLobby2 = 74,
    CsUmEndOfMatchAllPlayersData = 75,
    CsUmRoundImpactScoreData = 79,
    CsUmCurrentRoundOdds = 80,
    CsUmDeepStats = 81,
    CsUmUtilMsg = 82,
    CsUmUtilMsgResponse = 83,
}
impl ECstrike15UserMessages {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ECstrike15UserMessages::CsUmVguiMenu => "CS_UM_VGUIMenu",
            ECstrike15UserMessages::CsUmGeiger => "CS_UM_Geiger",
            ECstrike15UserMessages::CsUmTrain => "CS_UM_Train",
            ECstrike15UserMessages::CsUmHudText => "CS_UM_HudText",
            ECstrike15UserMessages::CsUmSayText => "CS_UM_SayText",
            ECstrike15UserMessages::CsUmSayText2 => "CS_UM_SayText2",
            ECstrike15UserMessages::CsUmTextMsg => "CS_UM_TextMsg",
            ECstrike15UserMessages::CsUmHudMsg => "CS_UM_HudMsg",
            ECstrike15UserMessages::CsUmResetHud => "CS_UM_ResetHud",
            ECstrike15UserMessages::CsUmGameTitle => "CS_UM_GameTitle",
            ECstrike15UserMessages::CsUmShake => "CS_UM_Shake",
            ECstrike15UserMessages::CsUmFade => "CS_UM_Fade",
            ECstrike15UserMessages::CsUmRumble => "CS_UM_Rumble",
            ECstrike15UserMessages::CsUmCloseCaption => "CS_UM_CloseCaption",
            ECstrike15UserMessages::CsUmCloseCaptionDirect => "CS_UM_CloseCaptionDirect",
            ECstrike15UserMessages::CsUmSendAudio => "CS_UM_SendAudio",
            ECstrike15UserMessages::CsUmRawAudio => "CS_UM_RawAudio",
            ECstrike15UserMessages::CsUmVoiceMask => "CS_UM_VoiceMask",
            ECstrike15UserMessages::CsUmRequestState => "CS_UM_RequestState",
            ECstrike15UserMessages::CsUmDamage => "CS_UM_Damage",
            ECstrike15UserMessages::CsUmRadioText => "CS_UM_RadioText",
            ECstrike15UserMessages::CsUmHintText => "CS_UM_HintText",
            ECstrike15UserMessages::CsUmKeyHintText => "CS_UM_KeyHintText",
            ECstrike15UserMessages::CsUmProcessSpottedEntityUpdate => {
                "CS_UM_ProcessSpottedEntityUpdate"
            }
            ECstrike15UserMessages::CsUmReloadEffect => "CS_UM_ReloadEffect",
            ECstrike15UserMessages::CsUmAdjustMoney => "CS_UM_AdjustMoney",
            ECstrike15UserMessages::CsUmUpdateTeamMoney => "CS_UM_UpdateTeamMoney",
            ECstrike15UserMessages::CsUmStopSpectatorMode => "CS_UM_StopSpectatorMode",
            ECstrike15UserMessages::CsUmKillCam => "CS_UM_KillCam",
            ECstrike15UserMessages::CsUmDesiredTimescale => "CS_UM_DesiredTimescale",
            ECstrike15UserMessages::CsUmCurrentTimescale => "CS_UM_CurrentTimescale",
            ECstrike15UserMessages::CsUmAchievementEvent => "CS_UM_AchievementEvent",
            ECstrike15UserMessages::CsUmMatchEndConditions => "CS_UM_MatchEndConditions",
            ECstrike15UserMessages::CsUmDisconnectToLobby => "CS_UM_DisconnectToLobby",
            ECstrike15UserMessages::CsUmPlayerStatsUpdate => "CS_UM_PlayerStatsUpdate",
            ECstrike15UserMessages::CsUmDisplayInventory => "CS_UM_DisplayInventory",
            ECstrike15UserMessages::CsUmWarmupHasEnded => "CS_UM_WarmupHasEnded",
            ECstrike15UserMessages::CsUmClientInfo => "CS_UM_ClientInfo",
            ECstrike15UserMessages::CsUmXRankGet => "CS_UM_XRankGet",
            ECstrike15UserMessages::CsUmXRankUpd => "CS_UM_XRankUpd",
            ECstrike15UserMessages::CsUmCallVoteFailed => "CS_UM_CallVoteFailed",
            ECstrike15UserMessages::CsUmVoteStart => "CS_UM_VoteStart",
            ECstrike15UserMessages::CsUmVotePass => "CS_UM_VotePass",
            ECstrike15UserMessages::CsUmVoteFailed => "CS_UM_VoteFailed",
            ECstrike15UserMessages::CsUmVoteSetup => "CS_UM_VoteSetup",
            ECstrike15UserMessages::CsUmServerRankRevealAll => {
                "CS_UM_ServerRankRevealAll"
            }
            ECstrike15UserMessages::CsUmSendLastKillerDamageToClient => {
                "CS_UM_SendLastKillerDamageToClient"
            }
            ECstrike15UserMessages::CsUmServerRankUpdate => "CS_UM_ServerRankUpdate",
            ECstrike15UserMessages::CsUmItemPickup => "CS_UM_ItemPickup",
            ECstrike15UserMessages::CsUmShowMenu => "CS_UM_ShowMenu",
            ECstrike15UserMessages::CsUmBarTime => "CS_UM_BarTime",
            ECstrike15UserMessages::CsUmAmmoDenied => "CS_UM_AmmoDenied",
            ECstrike15UserMessages::CsUmMarkAchievement => "CS_UM_MarkAchievement",
            ECstrike15UserMessages::CsUmMatchStatsUpdate => "CS_UM_MatchStatsUpdate",
            ECstrike15UserMessages::CsUmItemDrop => "CS_UM_ItemDrop",
            ECstrike15UserMessages::CsUmGlowPropTurnOff => "CS_UM_GlowPropTurnOff",
            ECstrike15UserMessages::CsUmSendPlayerItemDrops => {
                "CS_UM_SendPlayerItemDrops"
            }
            ECstrike15UserMessages::CsUmRoundBackupFilenames => {
                "CS_UM_RoundBackupFilenames"
            }
            ECstrike15UserMessages::CsUmSendPlayerItemFound => {
                "CS_UM_SendPlayerItemFound"
            }
            ECstrike15UserMessages::CsUmReportHit => "CS_UM_ReportHit",
            ECstrike15UserMessages::CsUmXpUpdate => "CS_UM_XpUpdate",
            ECstrike15UserMessages::CsUmQuestProgress => "CS_UM_QuestProgress",
            ECstrike15UserMessages::CsUmScoreLeaderboardData => {
                "CS_UM_ScoreLeaderboardData"
            }
            ECstrike15UserMessages::CsUmPlayerDecalDigitalSignature => {
                "CS_UM_PlayerDecalDigitalSignature"
            }
            ECstrike15UserMessages::CsUmWeaponSound => "CS_UM_WeaponSound",
            ECstrike15UserMessages::CsUmUpdateScreenHealthBar => {
                "CS_UM_UpdateScreenHealthBar"
            }
            ECstrike15UserMessages::CsUmEntityOutlineHighlight => {
                "CS_UM_EntityOutlineHighlight"
            }
            ECstrike15UserMessages::CsUmSsui => "CS_UM_SSUI",
            ECstrike15UserMessages::CsUmSurvivalStats => "CS_UM_SurvivalStats",
            ECstrike15UserMessages::CsUmDisconnectToLobby2 => "CS_UM_DisconnectToLobby2",
            ECstrike15UserMessages::CsUmEndOfMatchAllPlayersData => {
                "CS_UM_EndOfMatchAllPlayersData"
            }
            ECstrike15UserMessages::CsUmRoundImpactScoreData => {
                "CS_UM_RoundImpactScoreData"
            }
            ECstrike15UserMessages::CsUmCurrentRoundOdds => "CS_UM_CurrentRoundOdds",
            ECstrike15UserMessages::CsUmDeepStats => "CS_UM_DeepStats",
            ECstrike15UserMessages::CsUmUtilMsg => "CS_UM_UtilMsg",
            ECstrike15UserMessages::CsUmUtilMsgResponse => "CS_UM_UtilMsg_Response",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CS_UM_VGUIMenu" => Some(Self::CsUmVguiMenu),
            "CS_UM_Geiger" => Some(Self::CsUmGeiger),
            "CS_UM_Train" => Some(Self::CsUmTrain),
            "CS_UM_HudText" => Some(Self::CsUmHudText),
            "CS_UM_SayText" => Some(Self::CsUmSayText),
            "CS_UM_SayText2" => Some(Self::CsUmSayText2),
            "CS_UM_TextMsg" => Some(Self::CsUmTextMsg),
            "CS_UM_HudMsg" => Some(Self::CsUmHudMsg),
            "CS_UM_ResetHud" => Some(Self::CsUmResetHud),
            "CS_UM_GameTitle" => Some(Self::CsUmGameTitle),
            "CS_UM_Shake" => Some(Self::CsUmShake),
            "CS_UM_Fade" => Some(Self::CsUmFade),
            "CS_UM_Rumble" => Some(Self::CsUmRumble),
            "CS_UM_CloseCaption" => Some(Self::CsUmCloseCaption),
            "CS_UM_CloseCaptionDirect" => Some(Self::CsUmCloseCaptionDirect),
            "CS_UM_SendAudio" => Some(Self::CsUmSendAudio),
            "CS_UM_RawAudio" => Some(Self::CsUmRawAudio),
            "CS_UM_VoiceMask" => Some(Self::CsUmVoiceMask),
            "CS_UM_RequestState" => Some(Self::CsUmRequestState),
            "CS_UM_Damage" => Some(Self::CsUmDamage),
            "CS_UM_RadioText" => Some(Self::CsUmRadioText),
            "CS_UM_HintText" => Some(Self::CsUmHintText),
            "CS_UM_KeyHintText" => Some(Self::CsUmKeyHintText),
            "CS_UM_ProcessSpottedEntityUpdate" => {
                Some(Self::CsUmProcessSpottedEntityUpdate)
            }
            "CS_UM_ReloadEffect" => Some(Self::CsUmReloadEffect),
            "CS_UM_AdjustMoney" => Some(Self::CsUmAdjustMoney),
            "CS_UM_UpdateTeamMoney" => Some(Self::CsUmUpdateTeamMoney),
            "CS_UM_StopSpectatorMode" => Some(Self::CsUmStopSpectatorMode),
            "CS_UM_KillCam" => Some(Self::CsUmKillCam),
            "CS_UM_DesiredTimescale" => Some(Self::CsUmDesiredTimescale),
            "CS_UM_CurrentTimescale" => Some(Self::CsUmCurrentTimescale),
            "CS_UM_AchievementEvent" => Some(Self::CsUmAchievementEvent),
            "CS_UM_MatchEndConditions" => Some(Self::CsUmMatchEndConditions),
            "CS_UM_DisconnectToLobby" => Some(Self::CsUmDisconnectToLobby),
            "CS_UM_PlayerStatsUpdate" => Some(Self::CsUmPlayerStatsUpdate),
            "CS_UM_DisplayInventory" => Some(Self::CsUmDisplayInventory),
            "CS_UM_WarmupHasEnded" => Some(Self::CsUmWarmupHasEnded),
            "CS_UM_ClientInfo" => Some(Self::CsUmClientInfo),
            "CS_UM_XRankGet" => Some(Self::CsUmXRankGet),
            "CS_UM_XRankUpd" => Some(Self::CsUmXRankUpd),
            "CS_UM_CallVoteFailed" => Some(Self::CsUmCallVoteFailed),
            "CS_UM_VoteStart" => Some(Self::CsUmVoteStart),
            "CS_UM_VotePass" => Some(Self::CsUmVotePass),
            "CS_UM_VoteFailed" => Some(Self::CsUmVoteFailed),
            "CS_UM_VoteSetup" => Some(Self::CsUmVoteSetup),
            "CS_UM_ServerRankRevealAll" => Some(Self::CsUmServerRankRevealAll),
            "CS_UM_SendLastKillerDamageToClient" => {
                Some(Self::CsUmSendLastKillerDamageToClient)
            }
            "CS_UM_ServerRankUpdate" => Some(Self::CsUmServerRankUpdate),
            "CS_UM_ItemPickup" => Some(Self::CsUmItemPickup),
            "CS_UM_ShowMenu" => Some(Self::CsUmShowMenu),
            "CS_UM_BarTime" => Some(Self::CsUmBarTime),
            "CS_UM_AmmoDenied" => Some(Self::CsUmAmmoDenied),
            "CS_UM_MarkAchievement" => Some(Self::CsUmMarkAchievement),
            "CS_UM_MatchStatsUpdate" => Some(Self::CsUmMatchStatsUpdate),
            "CS_UM_ItemDrop" => Some(Self::CsUmItemDrop),
            "CS_UM_GlowPropTurnOff" => Some(Self::CsUmGlowPropTurnOff),
            "CS_UM_SendPlayerItemDrops" => Some(Self::CsUmSendPlayerItemDrops),
            "CS_UM_RoundBackupFilenames" => Some(Self::CsUmRoundBackupFilenames),
            "CS_UM_SendPlayerItemFound" => Some(Self::CsUmSendPlayerItemFound),
            "CS_UM_ReportHit" => Some(Self::CsUmReportHit),
            "CS_UM_XpUpdate" => Some(Self::CsUmXpUpdate),
            "CS_UM_QuestProgress" => Some(Self::CsUmQuestProgress),
            "CS_UM_ScoreLeaderboardData" => Some(Self::CsUmScoreLeaderboardData),
            "CS_UM_PlayerDecalDigitalSignature" => {
                Some(Self::CsUmPlayerDecalDigitalSignature)
            }
            "CS_UM_WeaponSound" => Some(Self::CsUmWeaponSound),
            "CS_UM_UpdateScreenHealthBar" => Some(Self::CsUmUpdateScreenHealthBar),
            "CS_UM_EntityOutlineHighlight" => Some(Self::CsUmEntityOutlineHighlight),
            "CS_UM_SSUI" => Some(Self::CsUmSsui),
            "CS_UM_SurvivalStats" => Some(Self::CsUmSurvivalStats),
            "CS_UM_DisconnectToLobby2" => Some(Self::CsUmDisconnectToLobby2),
            "CS_UM_EndOfMatchAllPlayersData" => Some(Self::CsUmEndOfMatchAllPlayersData),
            "CS_UM_RoundImpactScoreData" => Some(Self::CsUmRoundImpactScoreData),
            "CS_UM_CurrentRoundOdds" => Some(Self::CsUmCurrentRoundOdds),
            "CS_UM_DeepStats" => Some(Self::CsUmDeepStats),
            "CS_UM_UtilMsg" => Some(Self::CsUmUtilMsg),
            "CS_UM_UtilMsg_Response" => Some(Self::CsUmUtilMsgResponse),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EcsUsrMsgDisconnectToLobbyAction {
    KEcsUsrMsgDisconnectToLobbyActionDefault = 0,
    KEcsUsrMsgDisconnectToLobbyActionGoQueue = 1,
}
impl EcsUsrMsgDisconnectToLobbyAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EcsUsrMsgDisconnectToLobbyAction::KEcsUsrMsgDisconnectToLobbyActionDefault => {
                "k_ECSUsrMsg_DisconnectToLobby_Action_Default"
            }
            EcsUsrMsgDisconnectToLobbyAction::KEcsUsrMsgDisconnectToLobbyActionGoQueue => {
                "k_ECSUsrMsg_DisconnectToLobby_Action_GoQueue"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_ECSUsrMsg_DisconnectToLobby_Action_Default" => {
                Some(Self::KEcsUsrMsgDisconnectToLobbyActionDefault)
            }
            "k_ECSUsrMsg_DisconnectToLobby_Action_GoQueue" => {
                Some(Self::KEcsUsrMsgDisconnectToLobbyActionGoQueue)
            }
            _ => None,
        }
    }
}
